Những thử thách vui
Phần này cung cấp một số thử thách code thú vị để giới thiệu một vài chức năng được cung cấp bởi Go.

* Thợ cắt tóc ngủ gật

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Xem Video]]
- Cần hỗ trợ Học phí, hãy sử dụng [[https://www.ardanlabs.com/scholarship/][Đơn xin Học bổng]] của chúng tôi.

Chương trình ví dụ này sẽ xây dựng một bài tập về Thợ cắt tóc ngủ gật.

- Xem thêm tại [[https://en.wikipedia.org/wiki/Sleeping_barber_problem][https://en.wikipedia.org/wiki/Sleeping_barber_problem]]

Có một thợ cắt tóc trong tiệm, một chiếc ghế cắt tóc và `n` chiếc ghế cho
khách hàng đang đợi. Nếu không có khách, người thợ cắt tóc sẽ ngồi vào
ghế cắt tóc và ngủ trưa. Một khách hàng đến phải đánh thức thợ cắt tóc.
Những khách hàng đến tiếp theo sẽ ngồi vào ghế đợi nếu có ghế trống hoặc
bỏ đi nếu tất cả các ghế đã đầy.

*Đầu ra:*

    Opening the shop
    Barber ready to work
    Customer "cust-1" entered shop
    Customer "cust-1" takes a seat and waits
    Barber servicing customer "cust-1"
    Barber finished customer "cust-1"
    Barber taking a nap
    Customer "cust-2" entered shop
    Customer "cust-2" takes a seat and waits
    Barber servicing customer "cust-2"
    Customer "cust-3" entered shop
    Customer "cust-3" takes a seat and waits
    Barber finished customer "cust-2"
    Barber servicing customer "cust-3"
    Customer "cust-4" entered shop
    Customer "cust-4" takes a seat and waits
    Closing the shop
    Barber finished customer "cust-3"
    Barber servicing customer "cust-4"
    Barber finished customer "cust-4"
    Shop closed

    Mở cửa tiệm
    Thợ cắt tóc sẵn sàng làm việc
    Khách hàng "cust-1" bước vào tiệm
    Khách hàng "cust-1" ngồi vào ghế chờ
    Thợ cắt tóc phục vụ khách hàng "cust-1"
    Thợ cắt tóc cắt xong cho khách hàng "cust-1"
    Thợ cắt tóc ngủ trưa
    Khách hàng "cust-2" bước vào tiệm
    Khách hàng "cust-2" ngồi vào ghế chờ
    Thợ cắt tóc phục vụ khách hàng "cust-2"
    Khách hàng "cust-3" bước vào tiệm
    Khách hàng "cust-3" ngồi vào ghế chờ
    Thợ cắt tóc cắt xong cho khách hàng "cust-2"
    Thợ cắt tóc phục vụ khách hàng "cust-3"
    Khách hàng "cust-4" bước vào tiệm
    Khách hàng "cust-4" ngồi vào ghế chờ
    Cửa tiệm ngừng nhận khách
    Thợ cắt tóc cắt xong cho khách hàng "cust-3"
    Thợ cắt tóc phục vụ khách hàng "cust-4"
    Thợ cắt tóc cắt xong cho khách hàng "cust-4"
    Tiệm nghỉ

.chạy algorithms/fun/barber.go

* Tần suất

Chương trình ví dụ này chỉ cho bạn cách triển khai một hàm để tìm
tần suất của một chữ cổ (rune) nhất định được sử dụng trong một câu cụ thể.

- Tuần tự: Một thuật toán tuyến tính để thực hiện việc đếm chữ rune.
- Đồng thời: Một thuật toán đồng thời để thực hiện việc đếm chữ rune.

.chạy algorithms/fun/freq_sequential.go
.chạy algorithms/fun/freq_concurrent.go

*  Mã hóa/ giải mã Đại lượng biến thiên (Variable Length Quantity - VLQ).

Chương trình ví dụ này giới thiệu cách tận dụng Go để triển khai mã hóa/ giải mã số VLQ.

- Xem thêm tại [[https://en.wikipedia.org/wiki/Variable-length_code][https://en.wikipedia.org/wiki/Variable-length_code]]

Nói ngắn gọn, mục tiêu của việc mã hóa này là lưu các giá trị số nguyên mã hóa
theo một cách có thể tiết kiệm byte. Chỉ 7 bit đầu tiên của mỗi byte là có ý nghĩa
(căn lề phải; giống như một mã ASCII). Vì vậy, nếu bạn có giá trị 32 bit, bạn phải
giải nén nó thành một chuỗi byte 7 bit. Tất nhiên, bạn sẽ có số byte thay đổi
tùy theo số nguyên của bạn. Để chỉ ra cái nào là byte cuối cùng của chuỗi,
bạn để trống bit thứ 7. Trong tất cả các byte đứng trước, bạn cài đặt bit thứ 7.

Vì vậy, nếu một số nguyên nằm trong khoảng 0-127, nó có thể được biểu diễn
dưới dạng một byte. Số nguyên lớn nhất được cho phép là 0FFFFFFF, chuyển thành
số VLQ 4 byte. Dưới đây là ví dụ về sự chuyển đổi từ giá trị 32 bit sang
số VLQ:

    NUMBER        VARIABLE QUANTITY
    00000000              00
    00000040              40
    0000007F              7F
    00000080             81 00
    00002000             C0 00
    00003FFF             FF 7F
    00004000           81 80 00
    00100000           C0 80 00
    001FFFFF           FF FF 7F
    00200000          81 80 80 00
    08000000          C0 80 80 00
    0FFFFFFF          FF FF FF 7F

Đại lượng biến thiên (VLQ) là một mã phổ quát sử dụng một số octet nhị phân (tám bit)
tùy ý để biểu thị một giá trị số nguyên lớn tùy ý. Nó được xác định để sử dụng ở
định dạng tệp MIDI tiêu chuẩn[1] để tiết kiệm thêm không gian cho một hệ thống
có tài nguyên hạn chế và sau này cũng được sử dụng trong Định dạng nhạc mở rộng (XMF).
VLQ về cơ bản là base-128 biểu diễn một số nguyên không dấu có thêm bit thứ tám
để đánh dấu sự tiếp tục của byte. Xem ví dụ dưới đây.

	Int:    16384
	IntHex: 0x00004000
	IntBin: 00000000 00000000 01000000 00000000
	VLQHex: 0x81 0x80 0x00
	VLQBin: 00000000 10000001 10000000 00000000

Giả sử ta muốn biểu thị số 3435 trong VLQ. 3435 ở nhị phân
là 110101101011. Chúng tôi không thể khớp giá trị này trong một byte.
Vì vậy chúng tôi sẽ cắt nó thành khối 7 bit tính từ cuối lên.

    Khối	7	6	5	4	3	2	1
    #1		1	1	0	1	0	1	1
    #2		0	0	1	1	0	1	0

Bây giờ chúng ta thêm vào trước tất cả khối (trừ khối cuối cùng)
một bit giá trị 1 để chỉ ra rằng có một octet theo sau và
thêm bit giá trị 0 vào khối cuối cùng, báo hiệu đó là octet cuối cùng.

    Octet   8	7	6	5	4	3	2	1
    #1      0	1	1	0	1	0	1	1
    #2      1	0	0	1	1	0	1	0

Cuối cùng, chúng ta ghép chúng lại, octet quan trọng nhất đứng trước,
chuyển đổi thành:

Số ban đầu: 10011010 01101011  ToHex: 0x9A 0x6B

*Tài liệu* *bổ sung:*

- [[https://en.wikipedia.org/wiki/Variable-length_quantity][https://en.wikipedia.org/wiki/Variable-length_quantity]]
- [[https://blogs.infosupport.com/a-primer-on-vlq/][https://blogs.infosupport.com/a-primer-on-vlq/]]

*Một* *cách* *triển khai* *tuyệt vời* *cho* *thuật toán* *này* *ở* *đây:*

- [[https://github.com/go-audio/midi/blob/master/varint.go][https://github.com/go-audio/midi/blob/master/varint.go]]

.chạy algorithms/fun/vlq.go