Biến (Variables)
Biến là trái tim của ngôn ngữ cung cấp khả năng đọc và ghi vào bộ nhớ.

* Biến

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Xem Video]]
- Cần hỗ trợ Học phí, hãy sử dụng [[https://www.ardanlabs.com/scholarship/] [Đơn xin Học bổng]] của chúng tôi

Biến là trái tim của ngôn ngữ và cung cấp khả năng đọc và ghi vào bộ nhớ.
Trong Go, truy cập vào bộ nhớ phải an toàn. Điều này có nghĩa là trình biên dịch
rất coi trọng kiểu của biến và sẽ không cho phép chúng ta sử dụng biến ngoài phạm vi
được khai báo.

** Code Review

- *Ví dụ* *1*: Chương trình này cho biết cách khai báo biến.

.chạy variables/example1.go

** Các kiểu (Types) Built-in
Các kiểu dữ liệu cung cấp tính toàn vẹn và dễ đọc bằng cách đặt 2 câu hỏi:

- Dung lượng bộ nhớ được phân bổ là bao nhiêu? (Ví dụ 1, 2, 4, 8 bytes)
- Bộ nhớ đó biểu diễn cho cái gì? (Ví dụ int, uint, bool,..)

Các kiểu dữ liệu có thể được xác định rõ ràng như int32 or int64:

- uint8 biểu diễn cho một số nguyên không dấu được cấp 1 byte
- int32 biểu diễn cho một số nguyên có dấu được cấp 4 bytes

Khi bạn khai báo một kiểu dữ liệu không rõ ràng (unit, int) thì kích thước của biến
sẽ dựa trên kiến trúc được sử dụng để xây dựng chương trình:

- 32 bit arch: kiểu int biểu diễn cho một số nguyên có dấu được cấp 4 bytes bộ nhớ
- 64 bit arch: kiểu int biểu diễn cho một số nguyên có dấu được cấp 8 bytes bộ nhớ

** Word Size

Word size biểu diễn kích thước bộ nhớ cần thiết để lưu trữ số nguyên và con trỏ
cho một kiến trúc nhất định. Ví dụ:

- 32 bit arch: word size là 4 bytes bộ nhớ
- 64 bit arch: word size là 8 bytes bộ nhớ

Điều này quan trọng vì Go có cấu trúc dữ liệu nội bộ (maps, channels, slices, interfaces
và hàm) lưu trữ số nguyên và con trỏ. Kích thước của những cấu trúc dữ liệu này
sẽ dựa trên kiến trúc được sử dụng để xây dựng chương trình.

Trong Go, kích thước bộ nhớ được cấp cho một giá trị kiểu int, con trỏ hoặc một từ
sẽ luôn giống nhau trên cùng một kiến trúc.

** Khái niệm giá trị Zero
Mỗi biến bạn xây dựng trong Go đều được khởi tạo ở trạng thái giá trị Zero
trừ khi bạn chỉ định giá trị cụ thể khi khai báo. Giá trị Zero là mỗi bit
trong mỗi byte đều được cài đặt về Zero.

Việc này được thực hiện để đảm bảo tính toàn vẹn của dữ liệu và không miễn phí.
Cần có thời gian để đẩy electron thông qua máy để thiết lập lại các bit đó,
nhưng bạn phải luôn đảm bảo tính toàn vẹn trên cả hiệu suất.

    Kiểu               Giá trị Zero
    Boolean            false
    Integer            0
    Float              0
    Complex            0i
    String             "" (chuỗi rỗng)
    Pointer            nil

** Khai báo và Khởi tạo
Từ khóa var có thể được sử dụng để khai báo các biến về trạng thái giá trị Zero cho
tất cả các kiểu dữ liệu.

    var a int
    var b string
    var c float64
    var d bool

    fmt.Printf("var a int \t %T [%v]\n", a, a)
    fmt.Printf("var b string \t %T [%v]\n", b, b)
    fmt.Printf("var c float64 \t %T [%v]\n", c, c)
    fmt.Printf("var d bool \t %T [%v]\n\n", d, d)

Đầu ra:

    var a int    	int [0]
    var b string 	string []
    var c float64	float64 [0]
    var d bool   	bool [false]

Kiểu String sử dụng bộ mã ký tự UTF8, nhưng thực ra nó chỉ là một tập hợp các bytes.

Kiểu chuỗi là một cấu trúc dữ liệu nội bộ 2-word trong Go:

- Word đầu tiên đại diện cho một con trỏ tới một mảng hỗ trợ của byte
- Word thứ hai biểu thị độ dài hoặc số byte trong mảng hỗ trợ
- Nếu chuỗi được gán giá trị Zero của nó thì word đầu tiên là nil và
word thứ hai là 0.

Sử dụng toán tử khai báo biến ngắn, bạn có thể khai báo, xây dựng và
khởi tạo một giá trị cùng một lúc.

    aa := 10       // int [10]
    bb := "hello"  // string [hello]
    cc := 3.14159  // float64 [3.14159]
    dd := true     // bool [true]

    fmt.Printf("aa := 10 \t %T [%v]\n", aa, aa)
    fmt.Printf("bb := \"hello\" \t %T [%v]\n", bb, bb)
    fmt.Printf("cc := 3.14159 \t %T [%v]\n", cc, cc)
    fmt.Printf("dd := true \t %T [%v]\n\n", dd, dd)

Đầu ra:

    aa := 10         int [10]
    bb := "hello"    string [hello]
    cc := 3.14159    float64 [3.14159]
    dd := true       bool [true]

** Chuyển đổi vs ép kiểu (Conversion vs Casting)

Go không có tính năng ép kiểu mà chỉ có chuyển đổi. Thay vì yêu cầu trình biên dịch ép một
tập hợp các byte thành một cách biểu diễn khác, các byte này cần được sao chép sang một
vị trí bộ nhớ mới cho cách biểu diễn mới.

    aaa := int32(10)
    fmt.Printf("aaa := int32(10) %T [%v]\n", aaa, aaa)

    Output:
    aaa := int32(10) int32 [10]

Go có một gói trong thư viện chuẩn có tên là unsafe nếu bạn cần thực hiện
việc ép kiểu. Bạn thực sự nên tránh điều đó và tự hỏi chính mình tại sao
bạn lại cân nhắc sử dụng nó. Thực hiện chuyển đổi mang lại tính toàn vẹn
ở mức cao nhất cho các thao tác này.

** Ghi chú

- Mục đích của tất cả các chương trình và tất cả các phần của nó là chuyển đổi dữ liệu từ dạng này sang dạng khác.
- Mã nguồn chủ yếu phân bổ, đọc và ghi vào bộ nhớ.
- Hiểu rõ kiểu là tối quan trọng để viết mã tốt và hiểu mã.
- Nếu bạn không hiểu dữ liệu, bạn không hiểu được vấn đề.
- Bạn hiểu vấn đề tốt hơn bằng cách hiểu dữ liệu.
- Khi các biến đang được khai báo bằng giá trị 0 thì sử dụng từ khóa var.
- Khi các biến đang được khai báo và khởi tạo, hãy sử dụng toán tử khai báo biến ngắn gọn.

** Đọc thêm

- [[http://golang.org/ref/spec#Boolean_types][Built-In Types]]    
- [[https://golang.org/doc/effective_go.html#variables][Variables]]    
- [[https://www.ardanlabs.com/blog/2013/08/gustavos-ieee-754-brain-teaser.html][Gustavo's IEEE-754 Brain Teaser]] - William Kennedy    
- [[https://www.youtube.com/watch?v=sFUSP8Au_PE][What's in a name]]    
- [[http://arcanesentiment.blogspot.com/2015/01/a-brief-history-of-type.html][A brief history of “type”]] - Arcane Sentiment    

* Bài tập

Sử dụng bài mẫu làm điểm khởi đầu để hoàn thành các bài tập. Một câu trả lời khả thi đã được cung cấp.

** Bài tập 1

*Phần* *A:* Khai báo ba biến được khởi tạo bằng giá trị Zero và ba biến được khai báo
với giá trị cụ thể. Khai báo các biến kiểu string, int và bool.
Hiển thị giá trị của các biến đó.

*Phần* *B:* Khai báo một biến mới với kiểu là float32 và khởi tạo biến đó
bằng cách chuyển đổi giá trị cụ thể của Pi (3.14).

.chạy variables/exercise1.go
.chạy variables/answer1.go