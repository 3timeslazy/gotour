结构体类型
结构体类型是一种将数据字段组合在一起来创建复杂类型的方式

* 结构体类型

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][观看视频]]
- 需要经济支持, 请申请我们的奖学金 [[https://www.ardanlabs.com/scholarship/][申请表]]

结构体类型是一种将不同字段的数据组合在一起来创建复杂类型的方式，非常适用于组织和共享程序所需的不同数据。


计算机体系结构的潜在性能主要由其字长（每次访问可处理的位数）或者说更重要的是内存大小，即它可以访问的字数来确定。

** 代码审查

- *例子* *1:* 声明，创建和初始化结构体。
- *例子* *2:* 匿名结构体。
- *例子* *3:* 有名类型 vs 无名类型。
- *例子* *4:* 结构体数据对齐

.play struct-types/例子1.go
.play struct-types/例子2.go
.play struct-types/例子3.go
.play struct-types/例子4.go

** 结构体的创建机制

下面的这个声明表示一个用户定义的具体类型, 名为example，它是由不同的字段和具体类型组合而成的

    type example struct {
        flag    bool
        counter int16
        pi      float32
    }

声明example类型的变量，并且初始化为这个类型的零值。

    var e1 example

    fmt.Printf("%+v\n", e1)

输出:

    {flag:false counter:0 pi:0}

声明example类型的变量，并通过字面量来赋值。

    e2 := example{
        flag:    true,
        counter: 10,
        pi:      3.141592,
    }

    fmt.Println("Flag", e2.flag)
    fmt.Println("Counter", e2.counter)
    fmt.Println("Pi", e2.pi)

输出:

    Flag true
    Counter 10
    Pi 3.141592


使用字面量来创建一个匿名类型, 然后用此类型来声明变量，并通过字面量来赋值。

    e3 := struct {
        flag    bool
        counter int16
        pi      float32
    }{
        flag:    true,
        counter: 10,
        pi:      3.141592,
    }

    fmt.Println("Flag", e3.flag)
    fmt.Println("Counter", e3.counter)
    fmt.Println("Pi", e3.pi)

输出:

    Flag true
    Counter 10
    Pi 3.141592

使用字面量主要是为了创建匿名类型，可以用`var`关键字来赋零值，或使用`{}`来赋非零值。

** 对齐和填充

下面类型的值会占用多少内存？

    type example struct {
        flag    bool
        counter int16
        pi      float32
    }

一个布尔类型（bool）占用1字节，int16占用2字节，float32占用4字节。将它们相加，总共是7字节。
然而，实际的答案是8字节，这是因为为了保持内存对齐，位于标志字段和计数字段之间有一个填充字节。

.image /tour/eng/static/img/f1.png

对齐的概念是为了允许硬件更高效地读取内存，通过将内存放置在特定的对齐边界上。
编译器负责处理对齐边界的机制，因此不需要手动处理。

根据特定字段的大小和其在结构体中的位置，Go 决定所需的填充。

    type example2 struct {
        flag    bool
        counter int16
        flag2   bool
        pi      float32
    }

在这个示例中，我在counter字段和pi字段之间添加了一个新字段，名为 flag2。这导致结构体内部有更多的填充。

    type example2 struct {
        flag    bool     // 0xc000100020 <- Starting Address
                byte     // 0xc000100021 <- 1 byte padding
        counter int16    // 0xc000100022 <- 2 byte alignment
        flag2   bool     // 0xc000100024 <- 1 byte alignment
                byte     // 0xc000100025 <- 1 byte padding
                byte     // 0xc000100026 <- 1 byte padding
                byte     // 0xc000100027 <- 1 byte padding
        pi      float32  // 0xc000100028 <- 4 byte alignment
    }

这是当类型为 example2 的值从地址0xc000100020开始时，对齐和填充的工作方式。
flag字段代表起始地址，大小为1字节。由于counter字段需要2字节的分配空间，
它必须放置在内存上的2字节对齐位置，这意味着它需要位于2的倍数地址上。
这要求counter字段从地址0xc000100022开始。这在flag和counter字段之间创建了1字节的间隙。

.image /tour/eng/static/img/f2.png

flag2 字段是一个布尔类型，可以位于下一个地址0xc000100024。最后一个字段是 pi，
需要4字节的分配空间，因此它需要位于4字节对齐的位置。
4字节值的下一个地址是0xc000100028。这意味着需要额外的3个填充字节以保持正确的对齐。
这导致类型为 example2 的值需要总共分配12字节的内存空间。

在结构体中，最大的字段代表整个结构体的对齐边界。
在这种情况下，最大的字段是4字节，因此这个结构体值的起始地址必须是4的倍数。
可以看到地址0xc000100020是4的倍数。

如果需要最小化填充字节数，必须将字段从分配最大的字段到分配最小的字段的方式进行布局。
这将把任何必要的填充字节推到结构体的底部，并减少所需的总填充字节数。

    type example struct {
        pi      float32  // 0xc000100020 <- Starting Address
        counter int16    // 0xc000100024 <- 2 byte alignment
        flag    bool     // 0xc000100026 <- 1 byte alignment
        flag2   bool     // 0xc000100027 <- 1 byte alignment
    }

在字段重新排序后，结构体值只需要8字节的分配，而不是12字节。由于所有字段都允许结构体值以4字节对齐的方式放置，因此不需要额外的填充字节。

.image /tour/eng/static/img/f3.png

** 赋值

如果有两个在结构上完全相同的不同命名类型，不能将一个类型的值赋给另一个类型。

例如，如果使用完全相同的声明来声明类型 example1 和 example2，然后初始化两个变量。

    var ex1 example1
    var ex2 example2

不能将这两个变量互相赋值，因为它们属于不同的命名类型。它们在结构上完全相同是无关紧要的。

    ex1 = ex2  // 编译错误

一定要赋值的话, 可以使用类型转换，由于它们在结构上完全相同，编译器会允许这种操作。

    ex1 = example1(ex2)  // 无编译错误

然而，如果 ex2 的声明被更改为使用与 ex1 完全相同的声明的未命名类型，就不需要使用转换语法。

    var ex2 struct {
        flag    bool
        counter int16
        pi      float32
    }

    ex1 = ex2  // 无需类型转化

在这种情况下，编译器将允许进行这种赋值，无需进行转换。

** 简明要点

- 我们可以使用结构体字面形式来初始化结构类型一个值。
- 点号 (.) 运算符允许我们访问各个字段的值。
- 我们可以创建匿名结构体。

** 引用

"在编程中，类型的隐式转换就像万圣节特别节目一样令人头痛。想出它们的人可以下一个特别的地狱。"
- Martin Thompson

** 额外阅读

- [[https://www.ardanlabs.com/blog/2013/07/understanding-type-in-go.html][理解Go类型]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2013/07/object-oriented-programming-in-go.html][Go面向对象编程]] - William Kennedy
- [[https://dave.cheney.net/2015/10/09/padding-is-hard][不易的数据填充]] - Dave Cheney
- [[https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/][数据结构对齐，填充和数据打包]]
- [[http://www.catb.org/esr/structure-packing][数据结构打包的艺术]] - Eric S. Raymond

* 练习

使用模版来完成练习，有提供答案供参考。

** 练习 1

*任务* *A:* 声明一个结构体类型来存储有关用户的信息（姓名、电子邮件和年龄）。创建一个此类型的值，用值初始化，并显示每个字段。

*任务* *B:* 声明并初始化一个具有相同三个字段的匿名结构类型。显示其值。

.play struct-types/练习1.go
.play struct-types/答案1.go
