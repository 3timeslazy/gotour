Kupungua kwa(Decoupling)
Muundo huenda zaidi ya mechanics ya aina ya kupachika na ni zaidi ya dhana tu.

* Decoupling(Kupungua kwa)

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Watch The Video]]
- Iwapo Unahitaji msaada wa kifedha, tumia  [[https://www.ardanlabs.com/scholarship/][Scholarship Form]]

Njia bora ya kuchukua faida ya kupachika ni kupitia muundo wa muundo
Mfano. Ni ufunguo wa kudumisha utulivu katika programu yako kwa kuwa na
Uwezo wa kukabiliana na mabadiliko ya data na mabadiliko ambayo yanakuja.

** Mapitio ya Code

- *Mfano wa * *1:* Muundo wa muundo(Struct)
- *Mfano wa* *2:* Kuunganisha na interface
- *Mfano wa* *3:*  Muundo wa interface
- *Mfano wa* *4:* Decoupling na muundo wa interface
- *Mfano wa* *5:* Ondoa Uchafuzi wa interface
- *Mfano wa* *6:* API sahihi zaidi

.play composition/decoupling/example1.go
.play composition/decoupling/example2.go
.play composition/decoupling/example3.go
.play composition/decoupling/example4.go
.play composition/decoupling/example5.go
.play composition/decoupling/example6.go

** Njia Tofauti za Decoupling

Wazo ni kutunga aina kubwa kutoka kwa aina ndogo na kuzingatia muundo
ya tabia.

    type Xenia struct {
        Host    string
        Timeout time.Duration
    }

    func (*Xenia) Pull(d *Data) error {
        switch rand.Intn(10) {
        case 1, 9:
            return io.EOF
        case 5:
            return errors.New("Error reading data from Xenia")
        default:
            d.Line = "Data"
            fmt.Println("In:", d.Line)
            return nil
        }
    }

Aina ya Xenia inawakilisha mfumo ambao unahitaji kuvuta data kutoka. Utekelezaji wa
Sio ya muhimu. Cha muhimu ni kwamba njia ya kuvuta inaweza kufanikiwa, kushindwa, au
Hakuna data ya kuvuta.

    type Pillar struct {
        Host    string
        Timeout time.Duration
    }

    func (*Pillar) Store(d *Data) error {
        fmt.Println("Out:", d.Line)
        return nil
    }

Aina ya Pillar inawakilisha mfumo ambao unahitaji kuhifadhi data ndani. Nini maana ya
Muhimu tena ni kwamba njia ya kuhifadhi inaweza kufanikiwa au kushindwa.

Aina hizi mbili zinawakilisha safu ya zamani ya nambari ambayo hutoa tabia ya msingi
Inahitajika kutatua shida ya biashara ya kuvuta data kutoka kwa Xenia na kuhifadhi
data hiyo kwenye Pillar.

    func Pull(x *Xenia, data []Data) (int, error) {
        for i := range data {
            if err := x.Pull(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

    func Store(p *Pillar, data []Data) (int, error) {
        for i := range data {
            if err := p.Store(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

Safu inayofuata ya nambari inawakilishwa na kazi hizi mbili, Pull na Hifadhi. Wao
kujenga juu ya safu ya zamani ya kanuni kwa kukubali mkusanyiko wa maadili ya data kwa
kuvuta au kuhifadhi katika mifumo husika. Kazi hizi zinazingatia aina halisi
ya Xenia na Pillar kwani hizo ni mifumo ambayo programu inahitaji kufanya kazi nayo
Wakati huu.

    func Copy(sys *System, batch int) error {
        data := make([]Data, batch)

        for {
            i, err := Pull(&sys.Xenia, data)
            if i > 0 {
                if _, err := Store(&sys.Pillar, data[:i]); err != nil {
                    return err
                }
            }

            if err != nil {
                return err
            }
        }
    }

Kazi ya Nakala hujenga juu ya kazi za Pull na Duka ili kuhamisha yote
Data ambayo inasubiri kwa kila kukimbia. Ukiona parameta ya kwanza ya kunakili, ni
Aina inayoitwa System.

    type System struct {
        Xenia
        Pillar
    }

Wazo la awali la aina ya Mfumo ni kutunga mfumo ambao unajua jinsi ya kuvuta
na Hifadhi. Katika kesi hii, kutunga uwezo wa Pull na Hifadhi kutoka Xenia na Pillar.

    func main() {
        sys := System{
            Xenia: Xenia{
                Host:    "localhost:8000",
                Timeout: time.Second,
            },
            Pillar: Pillar{
                Host:    "localhost:9000",
                Timeout: time.Second,
            },
        }

        if err := Copy(&sys, 3); err != io.EOF {
            fmt.Println(err)
        }
    }

Hatimaye, kazi kuu inaweza kuandikwa ili kujenga Xenia na Pillar ndani ya
Muundo wa mfumo. Kisha mfumo unaweza kupitishwa kwa kazi ya Nakala
na data inaweza kuanza kutiririka kati ya mifumo miwili.

Kwa nambari hii yote, sasa una rasimu yangu ya kwanza ya suluhisho halisi kwa saruji
Tatizo.

**  Kuunganisha na Interfaces

Hatua inayofuata ni kuelewa nini kinaweza kubadilika katika programu. Katika kesi hii, nini
Inaweza kubadilika ni mifumo yenyewe. Leo ni Xenia na Pillar, kesho inaweza
Alisha & Bob. Kwa ufahamu huu, unataka kuondoa saruji iliyopo
suluhisho la mabadiliko hayo. Ili kufanya hivyo, unataka kubadilisha kazi halisi kuwa
Kuwa na kazi za polymorphic.

    func Pull(p Puller, data []Data) (int, error) {
        for i := range data {
            if err := p.Pull(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

    func Store(s Storer, data []Data) (int, error) {
        for i := range data {
            if err := s.Store(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

Hivi sasa, kazi ya Pull inakubali thamani ya Xenia na kazi ya Duka inakubali
thamani ya nguzo. Mwishowe, haikuwa Xenia na Pillar ambayo ilikuwa muhimu, ni nini
Muhimu ni thamani halisi ambayo inajua jinsi ya kuvuta na kuhifadhi. Unaweza kubadilisha hizi
kazi halisi kuwa polymorphic kwa kuuliza data kulingana na nini inaweza kufanya
badala ya kile ambacho ni.

    type Puller interface {
        Pull(d *Data) error
    }

    type Storer interface {
        Store(d *Data) error
    }

Violesura hivi viwili vinaelezea ni nini data halisi inapaswa kufanya na ni aina hizi ambazo
zinabadilishwa katika tamko la kazi za Pull na Hifadhi. Kwa sasa kazi hizi
Ni ya polymorphic. Wakati Alice na Bob wanatangazwa na kutekelezwa kama Puller na
Hifadhi, zinaweza kupitishwa katika kazi.


Bado hujafanya hivyo. Kazi ya nakala inahitaji kuwa polymorphic pia.

    func Copy(ps PullStorer, batch int) error {
        data := make([]Data, batch)

        for {
            i, err := Pull(ps, data)
            if i > 0 {
                if _, err := Store(ps, data[:i]); err != nil {
                    return err
                }
            }

            if err != nil {
                return err
            }
        }
    }

Kazi ya Nakala haiombi tena thamani ya Mfumo, lakini thamani yoyote halisi
hiyo inajua jinsi ya kuvuta na kuhifadhi.

    type PullStorer interface {
        Puller
        Storer
    }

Kiolesura cha PullStorer kinatangazwa kupitia matumizi ya muundo. Imetungwa
ya interfaces ya Puller na Storer. Kazi kuelekea kuunda interfaces kubwa
kutoka kwa wadogo zaidi.

Angalia jinsi tofauti ya PullStorer sasa inapitishwa kwenye Pull na Duka
Kazi. Je, hii inawezekanaje wakati habari ya aina ni tofauti?

    // func Pull(p Puller, data []Data) (int, error) {
    i, err := Pull(ps, data)

    // func Store(s Storer, data []Data) (int, error) {
    if _, err := Store(ps, data[:i]); err != nil {

Daima unahitaji kukumbuka, wewe kamwe kupita thamani interface karibu na programu yangu
kwa kuwa hazipo na hazina thamani. Unaweza tu kupitisha data halisi. Kwa hivyo
Data halisi iliyohifadhiwa ndani ya kiolesura cha PS ni nini kinachopitishwa
Kuvuta na kuhifadhi. Sio kweli, thamani halisi iliyohifadhiwa ndani ya ps lazima
Je, unajua jinsi ya kuhifadhi na kuhifadhi?

.image /tour/eng/static/img/comp1.png

Kwa kuwa Mfumo umeundwa kutoka kwa Xenia na Pillar, Mfumo hutekeleza PullStorer
Interface. Kwa mabadiliko haya, sasa unaweza kuunda aina mpya za saruji ambazo zinatekeleza
interface ya PullStorer.?

    type System1 struct {
        Xenia
        Pillar
    }

    type System2 struct {
        Alice
        Bob
    }

    type System3 struct {
        Xenia
        Bob
    }

    type System4 struct {
        Alice
        Pillar
    }

Unapofikiria juu ya hii zaidi, kutangaza aina tofauti za Mfumo kwa kila kitu kinachowezekana
Mchanganyiko sio wa kweli. Hii itafanya kazi, lakini ndoto ya matengenezo inahitaji
suluhisho bora zaidi.

** Muundo wa Interface


Ikiwa umeamua kutunga aina yangu ya mfumo halisi kutoka kwa aina mbili za interface?

    type System struct {
        Puller
        Storer
    }

Hii ni suluhisho la kuvutia. Hii itaruhusu programu hiyo kuingiza
saruji Puller au Storer katika mfumo wakati wa kuanza maombi. 

    func main() {
        sys := System{
            Puller: &Xenia{
                Host:    "localhost:8000",
                Timeout: time.Second,
            },
            Storer: &Pillar{
                Host:    "localhost:9000",
                Timeout: time.Second,
            },
        }

        if err := Copy(&sys, 3); err != io.EOF {
            fmt.Println(err)
        }
    }

Aina hii ya mfumo mmoja hutekeleza kiolesura cha PullStorer kwa wote iwezekanavyo
mchanganyiko wa aina halisi.

.image /tour/eng/static/img/comp2.png

Kwa mabadiliko haya, programu imeondolewa kabisa kutoka kwa mabadiliko ya mfumo mpya
Hii inaweza kuwa online kwa muda.

** Mapitio ya Usahihi

Swali linalofuata kuuliza ni, ni kazi za polymorphic kama sahihi kama wao
vinginevyo inaweza kuwa? Hii ni sehemu ya mchakato wa uhandisi ambao hauwezi kuruka.
Jibu ni hapana, mabadiliko mawili yanaweza kufanywa.

    func Copy(sys *System, batch int) error {

Kazi ya Nakala haiitaji kuwa polymorphic tena kwani kutakuwa na tu
aina ya mfumo mmoja. Aina ya kiolesura cha PullStorer inaweza kuondolewa kutoka kwa programu.
Kumbuka, ulihamisha polymorphism ndani ya aina wakati ulitumia muundo na
aina ya interface.

    func Copy(p Puller, s Storer, batch int) error {

Hii ni mabadiliko mengine ambayo yanaweza kufanywa kwa kazi ya Nakala. Mabadiliko haya yanafanya
kazi sahihi zaidi na polymorphic tena. Sasa kazi ni kuuliza kwa ajili ya hasa
kile kinachohitajika kulingana na kile data halisi inaweza kufanya.

.image /tour/eng/static/img/comp3.png

Kwa mabadiliko hayo aina ya muundo wa Mfumo inaweza kuondolewa kutoka kwa programu pia.

    func main() {
        x := Xenia{
            Host:    "localhost:8000",
            Timeout: time.Second,
        }

        p := Pillar{
            Host:    "localhost:9000",
            Timeout: time.Second,
        }

        if err := Copy(&x, &p, 3); err != io.EOF {
            fmt.Println(err)
        }
    }

Kwa kuondoa aina za PullStorer na Mfumo, programu hurahisisha. Kuu
kazi inaweza kuzingatia kujenga thamani halisi ya Puller na Storer muhimu
kwa data hiyo ya kusonga. Mfumo wa aina na API ni sahihi zaidi.
Wazo hili la usahihi linatokana na Edsger W. Dijkstra

"Lengo la abstraction sio kuwa wazi, lakini kuunda kiwango kipya cha semantic ambacho mtu anaweza kuwa sahihi kabisa". - Edsger W. Dijkstra

** Madokezo


- Hii ni zaidi ya mechanics ya kupachika aina.
- Kutangaza aina na kutekeleza mtiririko wa kazi na muundo katika akili.
- Fahamu tatizo unalojaribu kulitatua kwanza. Hii inamaanisha kuelewa data.
- Lengo ni kupunguza na kupunguza mabadiliko ya cascading katika programu yako.
- Interfaces hutoa aina ya juu ya muundo.
- Usiweke aina kwa DNA ya kawaida lakini kwa tabia ya kawaida.
- Kila mtu anaweza kufanya kazi pamoja wakati tunazingatia kile tunachofanya na sio kile tunachofanya.

** Ananukuu

"A good API is not just easy to use but also hard to misuse." - JBD

"You can always embed, but you cannot decompose big interfaces once they are out there. Keep interfaces small." - JBD

"Don't design with interfaces, discover them." - Rob Pike

"Duplication is far cheaper than the wrong abstraction. - Sandi Metz

** Miongozo ya Ubunifu

Jifunze kuhusu [[https://github.com/ardanlabs/gotraining/blob/master/topics/go/#interface-and-composition-design][design guidelines]] for composition.

** Kusoma kwa ziada

- [[https://programmingisterrible.com/post/176657481103/repeat-yourself-do-more-than-one-thing-and][Repeat yourself, do more than one thing, and rewrite everything]] - tef  
- [[https://golang.org/doc/effective_go.html#embedding][Embedding]]   
- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Methods, Interfaces and Embedding]] - William Kennedy  
- [[https://www.ardanlabs.com/blog/2015/09/composition-with-go.html][Composition In Go]] - William Kennedy  
- [[https://www.ardanlabs.com/blog/2016/10/reducing-type-hierarchies.html][Reducing Type Hierarchies]] - William Kennedy  
- [[https://www.ardanlabs.com/blog/2016/10/avoid-interface-pollution.html][Avoid Interface Pollution]] - William Kennedy 

* Mazoezi

Tumia template kama hatua ya kuanza kukamilisha mazoezi. Suluhisho linalowezekana linatolewa.

** Zoezi la kwanza

Kutumia template, tangaza seti ya aina halisi ambazo zinatekeleza seti ya predefined
aina ya interface. Kisha tengeneza maadili ya aina hizi na uzitumie kukamilisha seti ya
majukumu yaliyoainishwa awali.

.play composition/decoupling/exercise1.go
.play composition/decoupling/answer1.go
