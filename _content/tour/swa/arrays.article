Arrays(Safu)

Arrays ni muundo maalum wa data katika Go ambao unaturuhusu sisi kutenga vitalu vya kudumu vya kumbukumbu ya ukubwa wa kudumu.



* Arrays

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Angalia hii Video]]
- Iwapo unahitaji usaidizi wa kifedha, Una uhuru wa kutumia  [[https://www.ardanlabs.com/scholarship/][Scholarship Form]]

Arrays ni muundo maalum wa data katika Go ambayo inaruhusu sisi kutenga contiguous
vitalu vya kumbukumbu ya ukubwa wa kudumu. Arrays kuwa na baadhi ya vipengele maalum katika Go kuhusiana na
jinsi wanavyotangazwa na kuonekana kama aina.



** Tupitie Code

- *Mfano Wa* *1:* Kuanzisha na Kurudia
- *Mfano wa * *2:* Aina Tofauti za  arrays
- *Mfano wa * *3:* Contiguous memory allocations
- *Mfano wa * *4:* Range mechanics

.play arrays/example1.go
.play arrays/example2.go
.play arrays/example3.go
.play arrays/example4.go

** Kutangaza na Kuanzisha Values


Tangaza array ya strings  tano  iliyoanzishwa hadi hali yake ya sifuri.

    var strings [5]string


Kamba ni neno lisilobadilika, neno mbili, muundo wa data unaowakilisha kielekezi kwa a
safu kuu ya baiti na jumla ya idadi ya baiti katika safu inayounga mkono. Tangu
safu hii imewekwa kwa hali yake ya sifuri ya thamani, kila kipengele kimewekwa kwa thamani yake ya sifuri
jimbo. Hii ina maana kwamba kila mshororo una neno la kwanza lililowekwa kuwa nil na la pili
neno limewekwa kwa 0.


.image /tour/eng/static/img/a1.png

** String Assignments(Kazi za Kamba)

Je! ni nini hufanyika wakati kamba imeongezwa  kamba nyingine?
    strings[0] = "Apple"

Wakati kamba imepewa kamba nyingine, thamani ya maneno mawili inakiliwa,
kusababisha maadili mawili tofauti ya mfuatano wote kushiriki safu sawa ya usaidizi.


.image /tour/eng/static/img/a2.png

Gharama ya kunakili kamba ni sawa bila kujali ukubwa wa kamba, a
nakala ya maneno mawili.

** Iterating Over Collections(Kurudia Mikusanyiko)

Go hutoa semantiki mbili tofauti za kurudia juu ya mkusanyiko. Naweza kurudia
kwa kutumia semantiki za thamani au semantiki za vielelezo.


    // Value Semantic Iteration
    for i, fruit := range strings {
        println(i, fruit)
    }


    // Pointer Semantic Iteration
    for i := range strings {
        println(i, strings[i])
    }

Unapotumia urudiaji wa semantic wa thamani, mambo mawili hutokea. Kwanza, mkusanyiko mimi nina
iterating over imenakiliwa na unarudia juu ya nakala. Katika kesi ya safu,
nakala inaweza kuwa ghali kwa kuwa safu nzima imenakiliwa. Katika kesi ya kipande,
hakuna gharama halisi kwani ni thamani ya kipande cha ndani pekee ndiyo inakiliwa na sio
safu ya kuunga mkono. Pili, unapata nakala ya kila kipengele kinachorudiwa.

Unapotumia marudio ya kisemantiki ya kielekezi, unarudia mkusanyo asilia na mimi
fikia kila kipengele kinachohusishwa na mkusanyiko moja kwa moja.


** Value Semantic Iteration

Kwa kuzingatia Code  ifuatayo na matokeo.

    strings := [5]string{"Apple", "Orange", "Banana", "Grape", "Plum"}
    for i, fruit := range strings {
        println(i, fruit)
    }

Output:

    0 Apple
    1 Orange
    2 Banana
    3 Grape
    4 Plum

Tofauti ya nyuzi ni safu ya nyuzi 5. Kitanzi kinarudia juu ya kila mfuatano
kwenye mkusanyiko na kuonyesha nafasi ya faharisi na thamani ya kamba. Tangu hii
ni mrudisho wa kisemantiki wa thamani, safu ya masafa inarudia juu ya nakala yake yenye kina kifupi
ya safu na kwa kila marudio tofauti ya matunda ni nakala ya kila kamba
(muundo wa data ya maneno mawili).

Angalia jinsi utofauti wa matunda unavyopitishwa kwa chaguo la kukokotoa la kuchapisha kwa kutumia semantiki za thamani.
Kazi ya kuchapisha inapata nakala yake ya thamani ya kamba pia. Wakati ulipoasili
kamba hupitishwa kwa kazi ya uchapishaji, kuna nakala 4 za thamani ya kamba
(safu, nakala ya kina, mabadiliko ya matunda na nakala ya chaguo la kuchapisha). Nakala zote 4
wanashiriki safu sawa ya baiti. 

.image /tour/eng/static/img/a3.png

Kufanya nakala za thamani ya kamba ni muhimu kwa sababu inazuia thamani ya kamba
kutoka milele kutoroka hadi lundo. Hii inaondoa mgao usio na tija kwenye lundo.

** Pointer Semantic Iteration(Kurudia Semantiki za Pointers )

Kwa kuzingatia Code ifuatayo na matokeo.
    strings := [5]string{"Apple", "Orange", "Banana", "Grape", "Plum"}
    for i := range strings {
        println(i, strings[i])
    }

Output:

    0 Apple
    1 Orange
    2 Banana
    3 Grape
    4 Plum

Kwa mara nyingine tena, kutofautisha kwa masharti ni safu ya nyuzi 5. Kitanzi kinarudia tena
kila mfuatano kwenye mkusanyiko na huonyesha nafasi ya faharasa na thamani ya mfuatano.
Kwa kuwa hii ni marudio ya kisemantiki ya kielekezi, safu ya masafa inarudiwa juu ya
safu ya mifuatano moja kwa moja na kwa kila marudio, thamani ya mfuatano kwa kila faharasa
nafasi inapatikana moja kwa moja kwa simu ya kuchapisha.

** Different Type Arrays(Aina tofauti Arrays)

Inafurahisha kuona kile ambacho mkusanyaji hutoa kama hitilafu wakati wa kugawa
safu za aina sawa ambazo ni za urefu tofauti.

    var five [5]int
    four := [4]int{10, 20, 30, 40}

    five = four

Compiler Error:

    cannot use four (type [4]int) as type [5]int in assignment

Hapa unatangaza safu kamili ya 4 na 5 iliyoanzishwa hadi hali yake ya sifuri.
Kisha jaribu kuzigawa kwa kila mmoja na mkusanyaji anasema, "haiwezi kutumia nne
(aina [4]int) kama aina [5]int katika mgawo".



** Contiguous Memory Construction

Unataka kudhibitisha kuwa array hutoa mpangilio wa kumbukumbu.

    five := [5]string{"Annie", "Betty", "Charley", "Doug", "Bill"}

    for i, v := range five {
        fmt.Printf("Value[%s]\tAddress[%p]  IndexAddr[%p]\n",
            v, &v, &five[i])
    }

Output:

    Value[Annie]     Address[0xc000010250]    IndexAddr[0xc000052180]
    Value[Betty]     Address[0xc000010250]    IndexAddr[0xc000052190]
    Value[Charley]   Address[0xc000010250]    IndexAddr[0xc0000521a0]
    Value[Doug]      Address[0xc000010250]    IndexAddr[0xc0000521b0]
    Value[Bill]      Address[0xc000010250]    IndexAddr[0xc0000521c0]

Hapa unaanzisha array ya mifuatano 5 iliyoanzishwa kwa thamani. Kisha tumia thamani
urudiaji wa kisemantiki ili kuonyesha taarifa kuhusu kila mfuatano. Matokeo yanaonyesha
kila thamani ya mfuatano wa mtu binafsi, anwani ya kutofautisha v na anwani ya
kila kipengele katika safu.

Unaweza kuona jinsi safu ni kizuizi cha kumbukumbu na jinsi kamba ni mbili
neno au muundo wa data 16 kwenye usanifu wangu wa 64-bit. Anwani kwa kila kipengele
iko umbali wa hatua ya baiti 16.

Ukweli ni kwamba utofauti wa v una anwani sawa kwa kila marudio huimarisha
kuelewa kuwa v ni tofauti ya ndani ya kamba ya aina ambayo ina nakala ya kila moja
thamani ya kamba wakati wa kurudia.
** CPU Caches(Akiba za CPU
)


Kuna tofauti nyingi za kiufundi kati ya processsors  na muundo wao. Katika
sehemu hii, utazungumza kwa kiwango cha juu kuhusu wasindikaji na semantiki kwamba
ni sawa kati yao wote. Uelewa huu wa kisemantiki utatoa
wewe ni mfano mzuri wa kiakili wa jinsi kichakataji kinavyofanya kazi na huruma unayoweza kutoa.

Kila msingi ndani ya processor ina kashe yake ya ndani ya kumbukumbu (L1 na L2) na a
akiba ya kawaida ya kumbukumbu (L3) inayotumika kuhifadhi/kufikia data na maagizo. Vifaa
nyuzi katika kila msingi zinaweza kufikia kache zao za L1 na L2 za karibu. Data kutoka L3 au kuu
kumbukumbu inahitaji kunakiliwa kwenye kashe ya L1 au L2 kwa ufikiaji.
.image /tour/eng/static/img/a4.png

Gharama ya kusubiri ya kufikia data iliyopo katika akiba tofauti hubadilika kutoka
angalau kwa wengi: L1 -> L2 -> L3 -> kumbukumbu kuu. Kama Scott Meyers alivyosema, "Ikiwa utendaji
mambo basi jumla ya kumbukumbu unayo ni jumla ya kache. Kuu
kumbukumbu ni polepole sana kufikia, kwa kusema, inaweza pia kuwa haipo."

Utendaji leo ni kuhusu jinsi data inavyotiririka kupitia maunzi. Ikiwa kila
kipande cha data mahitaji ya vifaa (wakati wowote) ipo tu kwenye kumbukumbu kuu, my
programu zitaenda polepole ikilinganishwa na data ambayo tayari iko kwenye kache za L1 au L2.

    3GHz(3 clock cycles/ns) * 4 instructions per cycle = 12 instructions per ns!

    1 ns ............. 1 ns .............. 12 instructions  (one) 
    1 Âµs ......... 1,000 ns .......... 12,000 instructions  (thousand)
    1 ms ..... 1,000,000 ns ...... 12,000,000 instructions  (million)
    1 s .. 1,000,000,000 ns .. 12,000,000,000 instructions  (billion)

    Industry Defined Latencies
    L1 cache reference ......................... 0.5 ns ...................  6 ins
    L2 cache reference ........................... 7 ns ................... 84 ins
    Main memory reference ...................... 100 ns ................. 1200 ins


Unaandikaje code  inayohakikisha  data inayohitajika kutekeleza maagizo
iko kila wakati kwenye kache za L1 au L2? Unahitaji kuandika nambari ambayo ni ya kiufundi
huruma na prefetcher ya processor. Mtangulizi anajaribu kutabiri nini
data inahitajika kabla ya maagizo kuomba data kwa hivyo tayari iko katika aidha
kashe ya L1 au L2.

Kuna chembechembe tofauti za ufikiaji wa kumbukumbu kulingana na mahali ufikiaji ulipo
kutokea. Nambari yangu inaweza kusoma/kuandika kumbukumbu kidogo kama sehemu ndogo zaidi ya kumbukumbu
ufikiaji. Hata hivyo, kutoka kwa mtazamo wa mifumo ya caching, granularity ni 64 byte.
Kizuizi hiki cha kumbukumbu cha byte 64 kinaitwa mstari wa kache.

Prefetcher hufanya kazi vyema zaidi maagizo yanayotekelezwa yanapoweza kutabirika
mifumo ya kufikia kumbukumbu. Njia moja ya kuunda muundo wa ufikiaji unaotabirika kwa kumbukumbu
ni kuunda kizuizi cha kumbukumbu na kisha kurudia juu ya kumbukumbu hiyo
kutekeleza upitishaji wa mstari kwa hatua inayotabirika.

Safu ni muundo muhimu zaidi wa data kwa maunzi kwa sababu inasaidia
mifumo ya ufikiaji inayotabirika. Walakini, kipande ndio muundo muhimu zaidi wa data
katika Go. Vipande katika Go hutumia safu iliyo chini.

Mara tu unapounda array(Safu), kila kipengee kiko mbali sawa na kinachofuata au
kipengele kilichotangulia. Unaporudia safu, unaanza kutembea kwenye mstari wa kache
iliunganisha mstari wa kache kwa hatua inayoweza kutabirika. Prefetcher itachukua hii
muundo wa ufikiaji wa data unaotabirika na kuanza kuvuta data kwa ufanisi kwenye
processor, hivyo kupunguza gharama za muda wa kufikia data.

Fikiria una kumbukumbu kubwa ya mraba na orodha iliyounganishwa ya nodi zinazolingana
idadi ya vipengele kwenye tumbo. Ikiwa utafanya mapitio katika sehemu zilizounganishwa
list, na kisha upitishe matrix katika pande zote mbili (Safuwima na Safu), itakuwaje
utendaji wa mapito tofauti kulinganisha?

    func RowTraverse() int {
        var ctr int
        for row := 0; row < rows; row++ {
            for col := 0; col < cols; col++ {
                if matrix[row][col] == 0xFF {
                    ctr++
                }
            }
        }
        return ctr
    }
Kupitia safu mlalo kutakuwa na utendakazi bora zaidi kwa sababu hupitia kumbukumbu, akiba
mstari kwa mstari wa kache uliounganishwa, ambao huunda muundo wa ufikiaji unaotabirika. Mistari ya akiba
inaweza kuletwa na kunakiliwa kwenye kache ya L1 au L2 kabla ya data kuhitajika.

    func ColumnTraverse() int {
        var ctr int
        for col := 0; col < cols; col++ {
            for row := 0; row < rows; row++ {
                if matrix[row][col] == 0xFF {
                    ctr++
                }
            }
        }
        return ctr
    }

Column Traverse ndiyo mbaya zaidi kwa mpangilio wa ukubwa kwa sababu muundo huu wa ufikiaji
huvuka mipaka ya ukurasa wa OS kwenye kila ufikiaji wa kumbukumbu. Hii husababisha kutokuwa na utabiri
kwa uletaji mapema wa mstari wa kache na inakuwa kumbukumbu ya ufikiaji bila mpangilio.

    func LinkedListTraverse() int {
        var ctr int
        d := list
        for d != nil {
            if d.v == 0xFF {
                ctr++
            }
            d = d.p
        }
        return ctr
    }

Orodha iliyounganishwa ni ya polepole mara mbili ya upitishaji wa safu mlalo hasa kwa sababu kuna akiba
line hukosa lakini TLB chache (Tafsiri Lookaside Buffer) hukosa. Wingi wa nodi
zilizounganishwa kwenye orodha zipo ndani ya kurasa zile zile za OS.

    BenchmarkLinkListTraverse-16    128      28738407 ns/op
    BenchmarkColumnTraverse-16       30     126878630 ns/op
    BenchmarkRowTraverse-16         310      11060883 ns/op

** Translation Lookaside Buffer (TLB)

Kila programu inayoendesha inapewa ramani kamili ya kumbukumbu ya kumbukumbu halisi na OS na hiyo
inayoendesha programu inafikiria wana kumbukumbu yote ya mwili kwenye mashine. Hata hivyo,
kumbukumbu ya kimwili inahitaji kushirikiwa na programu zote zinazoendesha. Mfumo wa uendeshaji
hushiriki kumbukumbu ya kimwili kwa kuvunja kumbukumbu halisi katika kurasa na kurasa za ramani
kwa kumbukumbu halisi kwa programu yoyote inayoendesha. Kila OS inaweza kuamua ukubwa wa ukurasa,
lakini 4k, 8k, 16k ni saizi zinazokubalika na za kawaida.

TLB ni akiba ndogo ndani ya kichakataji ambayo husaidia kupunguza muda kuwaka
kutafsiri anwani pepe kwa anwani halisi ndani ya mawanda ya ukurasa wa Mfumo wa Uendeshaji
na kukabiliana ndani ya ukurasa. Kukosa dhidi ya akiba ya TLB kunaweza kusababisha ucheleweshaji mkubwa
kwa sababu sasa vifaa vinapaswa kusubiri OS kuchambua jedwali la ukurasa wake ili kupata
ukurasa sahihi wa anwani pepe inayohusika. Ikiwa programu inaendelea
mashine ya mtandaoni (kama kwenye wingu) basi jedwali la kurasa za mashine linahitaji
kuchunguzwa kwanza.

Kumbuka kilichosemwa:
Orodha iliyounganishwa ni ya polepole mara mbili ya upitishaji wa safu mlalo hasa kwa sababu kuna akiba
mstari hukosa lakini TLB chache hukosa (imeelezwa ijayo). Wingi wa nodi zilizounganishwa ndani
orodha zipo ndani ya kurasa sawa za OS.

Orodha Iliyounganishwa ni maagizo ya ukubwa kwa kasi zaidi kuliko safu wima kwa sababu ya
Ufikiaji wa TLB. Ingawa kuna makosa ya kache na mtiririko wa orodha iliyounganishwa,
kwa kuwa kumbukumbu nyingi za kikundi cha nodi zitatua ndani ya ukurasa huo huo,
Ucheleweshaji wa TLB hauathiri utendakazi. Hii ndio sababu kwa programu zinazotumia a
kiasi kikubwa cha kumbukumbu, kama utumizi wa msingi wa DNA, unaweza kutaka kutumia usambazaji
ya Linux ambayo imesanidiwa kwa ukubwa wa ukurasa kwa mpangilio wa megabaiti au mbili za kumbukumbu.

Yote yakishasemwa, muundo unaozingatia data ni muhimu. Kuandika algorithm ya ufanisi inabidi
kuzingatia jinsi data inavyopatikana. Kumbuka, utendaji leo unakaribia
jinsi unavyoweza kupata data kwenye kichakataji kwa ufanisi.

- [[https://youtu.be/WDIkqP4JbkE?t=1129][CPU Caches and Why You Care (18:50-20:30)]] - Scott Meyers  
- [[https://youtu.be/WDIkqP4JbkE?t=2676][CPU Caches and Why You Care (44:36-45:40)]] - Scott Meyers   
- [[https://youtu.be/jEG4Qyo_4Bc?t=266][Performance Through Cache-Friendliness (4:25-5:48)]] - Damian Gryski  

** Vidokezo vya Cache ya CPU

.html arrays/array_list.html

** Michoro ya Ziada

*Industry* *Defined* *Latencies*

    L1 cache reference ......................... 0.5 ns ...................  6 ins
    Branch mispredict ............................ 5 ns ................... 60 ins
    L2 cache reference ........................... 7 ns ................... 84 ins
    Mutex lock/unlock ........................... 25 ns .................. 300 ins
    Main memory reference ...................... 100 ns ................. 1200 ins           
    Compress 1K bytes with Zippy ............. 3,000 ns (3 Âµs) ........... 36k ins
    Send 2K bytes over 1 Gbps network ....... 20,000 ns (20 Âµs) ........  240k ins
    SSD random read ........................ 150,000 ns (150 Âµs) ........ 1.8M ins
    Read 1 MB sequentially from memory ..... 250,000 ns (250 Âµs) .......... 3M ins
    Round trip within same datacenter ...... 500,000 ns (0.5 ms) .......... 6M ins
    Read 1 MB sequentially from SSD- ..... 1,000,000 ns (1 ms) ........... 12M ins
    Disk seek ........................... 10,000,000 ns (10 ms) ......... 120M ins
    Read 1 MB sequentially from disk .... 20,000,000 ns (20 ms) ......... 240M ins
    Send packet CA->Netherlands->CA .... 150,000,000 ns (150 ms) ........ 1.8B ins

*Cache* *Latencies* *Image*

.image /tour/eng/static/img/cache_latencies_graph.png

** Usomaji wa Ziada

*CPU* *Caches* */* *Memory*

- [[https://www.youtube.com/watch?v=WDIkqP4JbkE][CPU Caches and Why You Care - Video]] - Scott Meyers  
- [[https://www.youtube.com/watch?v=OFgxAFdxYAQ][A Crash Course in Modern Hardware - Video]] - Cliff Click  
- [[http://frankdenneman.nl/2016/07/06/introduction-2016-numa-deep-dive-series/][NUMA Deep Dive Series]] - Frank Denneman    
- [[http://www.aristeia.com/TalkNotes/codedive-CPUCachesHandouts.pdf][CPU Caches and Why You Care - Deck]] - Scott Meyers  
- [[https://www.youtube.com/watch?v=MC1EKLQ2Wmg][Mythbusting Modern Hardware to Gain 'Mechanical Sympathy']] - Martin Thompson  
- [[http://www.akkadia.org/drepper/cpumemory.pdf][What Every Programmer Should Know About Memory]] - Ulrich Drepper  
- [[http://www.extremetech.com/extreme/188776-how-l1-and-l2-cpu-caches-work-and-why-theyre-an-essential-part-of-modern-chips][How CPU Caches Work and Why]] - Joel Hruska  
- [[http://www.lighterra.com/papers/modernmicroprocessors][Modern Microprocessors A 90 Minute Guide]] - Jason Robert Carey Patterson  
- [[http://lwn.net/Articles/252125][Memory part 2: CPU caches]] - Ulrich Drepper  
- [[http://www.gotw.ca/publications/concurrency-ddj.htm][The Free Lunch Is Over]] - Herb Sutter  
- [[https://m.youtube.com/watch?feature=youtu.be&v=QBu2Ae8-8LM][Data Center Computers: Modern Challenges in CPU Design]] - Dick Sites  
- [[https://en.wikipedia.org/wiki/Wirth%27s_law][Wirth's Law]] - Wikipedia  
- [[http://www.drdobbs.com/parallel/eliminate-false-sharing/217500206][Eliminate False Sharing]] - Herb Sutter  
- [[http://www.ilikebigbits.com/2014_04_21_myth_of_ram_1.html][The Myth Of Ram]] - Emil Ernerfeldt  
- [[https://www.infoq.com/presentations/hardware-transactional-memory][Understanding Transaction Hardware Memory]] - Gil Gene  
- [[https://youtu.be/jEG4Qyo_4Bc?t=266][Performance Through Cache-Friendliness (4:25-5:48)]] - Damian Gryski   
- [[https://www.youtube.com/watch?v=2EWejmkKlxs][Going Nowhere Faster]] - Chandler Carruth  

*Data-Oriented* *Design*

- [[https://www.youtube.com/watch?v=rX0ItVEVjHc][Data-Oriented Design and C++]] - Mike Acton  
- [[https://www.youtube.com/watch?v=fHNmRkzxHWs][Efficiency with Algorithms, Performance with Data Structures]] - Chandler Carruth  
- [[https://www.youtube.com/watch?v=LrVi9LHP8Bk][Taming the performance Beast]] - Klaus Iglberger  
- [[http://harmful.cat-v.org/software/OO_programming/_pdf/Pitfalls_of_Object_Oriented_Programming_GCAP_09.pdf][Pitfalls of OOP]] - Tony Albrecht  
- [[https://www.youtube.com/watch?v=YQs6IC-vgmo][Why you should avoid Linked Lists]] - Bjarne Stroustrup  
- [[http://gamesfromwithin.com/data-oriented-design][Data-Oriented Design (Or Why You Might Be Shooting Yourself in The Foot With OOP)]] - Noel    
- [[https://www.quora.com/Was-object-oriented-programming-a-failure][Was object-oriented programming a failure?]] - Quora  

** Vidokezo

- If you don't understand the data, you don't understand the problem.
- If you don't understand the cost of solving the problem, you can't reason about the problem.
- If you don't understand the hardware, you can't reason about the cost of solving the problem.
- Arrays are fixed length data structures that can't change.
- Arrays of different sizes are considered to be of different types.
- Memory is allocated as a contiguous block.
- Go gives you control over spacial locality.

* Mazoezi ya Ziada

Use the template as a starting point to complete the exercises. A possible solution
is provided.

** Exercise 1

Declare an array of 5 strings with each element initialized to its zero value. Declare
a second array of 5 strings and initialize this array with literal string values. Assign
the second array to the first and display the results of the first array. Display the
string value and address of each element.

.play arrays/exercise1.go
.play arrays/answer1.go
