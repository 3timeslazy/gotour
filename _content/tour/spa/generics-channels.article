Canales
Explora cómo el equipo de Go podría agregar un paquete de patrones de concurrencia en la biblioteca estándar gracias a los tipos de datos genéricos.

* Programación Genérica - Canales

Explora cómo el equipo de Go podría agregar un paquete de patrones de concurrencia en la biblioteca estándar gracias a los tipos de datos genéricos.

** Video

Mira la charla que di sobre la Programación Genérica, que te guiará a través de todos los ejemplos de esta sección del Tour.

.html generics-video.html

** Revisión de Código

- *Ejemplo* *1*: Trabajo
- *Ejemplo* *2*: "Pooling"

.play generics/channels/example1.go
.play generics/channels/example2.go

** Explicando conceptos

Esto requeriría declarar canales y funciones utilizando tipos genéricos.

    type workFn[Result any] func(context.Context) Result

En este ejemplo, se declara un tipo que representa una función que acepta un contexto
y devuelve un valor de tipo genérico Resultado. Esta declaración describe una 
función que implementa el trabajo concurrente que se realizará y el resultado de ese trabajo.

    func doWork[Result any](ctx context.Context, work workFn[Result]) chan Result {
        ch := make(chan Result, 1)
        
        go func() {
            ch <- work(ctx)
            fmt.Println("doWork : work complete")
        }()
        
        return ch
    }

Ahora, escribiré una función llamada doWork que ejecute la función de trabajo especificada
de manera concurrente y devuelva un canal para que el llamador pueda recibir el resultado del
trabajo realizado por la función de trabajo. Se declara un tipo genérico llamado Result para
representar el tipo de retorno de la función de trabajo y el tipo del canal.

En la implementación de la función doWork, se construye un canal con búfer de uno de tipo genérico 
Result. Este es el canal que se devuelve al llamador para recibir el resultado del trabajo concurrente.
En medio de la función, se construye un goroutine para ejecutar la función de trabajo de manera concurrente. 
na vez que la función de trabajo devuelve un valor, ese valor se envía de vuelta al llamador a través del canal.

Para probar el uso de la función doWork, construye un pequeño programa

    func main() {
        duration := 100 * time.Millisecond
        
        ctx, cancel := context.WithTimeout(context.Background(), duration)
        defer cancel()
        
        dwf := func(ctx context.Context) string {
            time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond)
            return "work complete"
        }

        result := doWork(ctx, dwf)
        
        select {
            case v := <-result:
                fmt.Println("main:", v)
            case <-ctx.Done():
                fmt.Println("main: timeout")
        }
    }

Salida:

    doWork : work complete
    main: work complete

El programa comienza declarando un contexto que caducará en 100 milisegundos. 
Luego se declara una función de trabajo que espera hasta 200 milisegundos antes de devolver 
la cadena "work complete". Con el contexto y la función de trabajo en su lugar, se realiza una
llamada a `doWork`, y se devuelve un canal de tipo `string`, que se asigna a la variable `resultado`.

El compilador puede determinar el tipo concreto a utilizar para el tipo genérico `Result` inspeccionando 
el tipo de retorno de la función de trabajo literal que se pasa a la función `doWork`. 
Esto es brillante porque significa que no tuvo que pasar el tipo en la llamada a `doWork`.

Con el canal de tipo `string` asignado a la variable `resultado`, se utiliza una sentencia `select` 
para esperar a que se devuelva el resultado a tiempo o para que ocurra el tiempo de espera. 
La función `doWork` se puede utilizar para realizar este trabajo concurrente para cualquier tipo concreto necesario.

Esta misma idea podría aplicarse a un conjunto de "goroutines" que podrían ejecutar trabajo 
en una entrada genérica y devolver un resultado genérico.

type workFn[Input any, Result any] func(input Input) Result

En este ejemplo, cambia el tipo de función para aceptar una entrada genérica y devolver un resultado genérico.

    func poolWork[Input any, Result any](size int, work workFn[Input, Result]) (chan Input, func()) {
        var wg sync.WaitGroup
        wg.Add(size)
        
        ch := make(chan Input)
        
        for i := 0; i < size; i++ {
            go func() {
                defer wg.Done()
                for input := range ch {
                    result := work(input)
                    fmt.Println("pollWork :", result)
                }
            }()
        }
        
        cancel := func() {
            close(ch)
            wg.Wait()
        }

        return ch, cancel
    }

En la función poolWork, se declaran los mismos dos tipos genéricos para representar el tipo de entrada 
y de retorno de la función de trabajo. Se construye un WaitGroup para gestionar el ciclo de vida de 
las goroutines en el grupo. Luego, se crea un canal del tipo Input genérico. Este canal es utilizado 
por las goroutines en el grupo para recibir los datos de entrada para la función de trabajo.

Luego se crea el grupo de goroutines, y cada goroutine espera en una operación de recepción utilizando 
un bucle for-range en el canal. Finalmente, se construye una función de cancelación que permite al llamador 
terminar el grupo y esperar a que todas las goroutines señalen que han terminado.

Para probar el uso de la función poolWork, construimos un segundo programa pequeño.

    func main() {
        size := runtime.GOMAXPROCS(0)
        
        pwf := func(input int) string {
            time.Sleep(time.Duration(rand.Intn(200)) * time.Millisecond)
            return fmt.Sprintf("%d : received", input)
        }

        ch, cancel := poolWork(size, pwf)
        defer cancel()
        
        for i := 0; i < 4; i++ {
            ch <- i
        }
    }

Salida:

    pollWork : 3 : received
    pollWork : 2 : received
    pollWork : 1 : received
    pollWork : 0 : received

El tamaño del grupo se calcula en función del número de goroutines que pueden ejecutarse en paralelo. 
Luego, se construye una función de trabajo que se duerme durante una cantidad aleatoria de tiempo 
y luego devuelve una cadena que representa la entrada.

Con eso en su lugar, se ejecuta la función poolWork y se obtiene el canal y la función de cancelación. 
La función de cancelación se retrasa y se construye un bucle para enviar 4 valores al grupo. 
La salida será diferente cada vez que se ejecute el programa, ya que este trabajo se realiza de manera concurrente.

Estos pequeños ejemplos proporcionan una visión de cómo podría implementarse un paquete concurrente.
