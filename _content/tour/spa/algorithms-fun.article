Problemas Divertidos
Esta sección contiene una serie de desafíos de código divertidos que muestran algunas de las capacidades ofrecidas por Go.

* Problema del Barbero Dormilón

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Ver el video]]
- Si necesita asistencia financiera, utilice nuestro [[https://www.ardanlabs.com/scholarship/][Formulario de becas]]

Este programa de muestra implementa el problema del Barbero Dormilón.

- Más información en [[https://en.wikipedia.org/wiki/Sleeping_barber_problem][https://en.wikipedia.org/wiki/Sleeping_barber_problem]]

En la barbería hay un barbero, una silla de barbero y n sillas para los clientes que esperan. 
Si no hay clientes, el barbero se sienta en la silla de barbero y se echa una siesta. 
Un cliente que llega debe despertar al barbero. Los clientes que llegan posteriormente 
ocupan una silla de espera si hay alguna disponible o se van si todas las sillas están 
ocupadas.

*Salida:*

    Opening the shop
    Barber ready to work
    Customer "cust-1" entered shop
    Customer "cust-1" takes a seat and waits
    Barber servicing customer "cust-1"
    Barber finished customer "cust-1"
    Barber taking a nap
    Customer "cust-2" entered shop
    Customer "cust-2" takes a seat and waits
    Barber servicing customer "cust-2"
    Customer "cust-3" entered shop
    Customer "cust-3" takes a seat and waits
    Barber finished customer "cust-2"
    Barber servicing customer "cust-3"
    Customer "cust-4" entered shop
    Customer "cust-4" takes a seat and waits
    Closing the shop
    Barber finished customer "cust-3"
    Barber servicing customer "cust-4"
    Barber finished customer "cust-4"
    Shop closed

.play algorithms/fun/barber.go

* Frecuencia

Este programa de muestra te muestra cómo implementar una función 
que puede encontrar la frecuencia de un carácter específico usado 
en una oración especificada.

- Secuencial: Un algoritmo lineal para contar runas.
- Concurrente: Un algoritmo concurrente para contar runas.

.play algorithms/fun/freq_sequential.go
.play algorithms/fun/freq_concurrent.go

* Codificación/decodificación de Cantidad de Longitud Variable.

Este programa de muestra demuestra cómo Go puede ser utilizado para implementar 
codificación/decodificación de cantidad de longitud variable.

- Más información en [[https://en.wikipedia.org/wiki/Variable-length_code][https://en.wikipedia.org/wiki/Variable-length_code]]

En resumen, el objetivo de esta codificación es ahorrar bytes al codificar 
valores enteros de una manera que ahorre espacio. Solo los primeros 7 bits 
de cada byte son significativos (justificados a la derecha; algo así como 
un byte ASCII). Entonces, si tienes un valor de 32 bits, debes descomponerlo
en una serie de bytes de 7 bits. Por supuesto, tendrás un número variable 
de bytes dependiendo de tu número entero. Para indicar cuál es el último 
byte de la serie, dejas el bit n.° 7 sin marcar. En todos los bytes anteriores, 
marcas el bit n.° 7.

Entonces, si un entero está entre 0-127, se puede representar como un byte. 
El entero más grande permitido es 0FFFFFFF, que se traduce en una longitud 
variable de 4 bytes. Aquí tienes ejemplos de tiempos de delta como valores 
de 32 bits y las cantidades de longitud variable a las que se traducen:

    NÚMERO        CANTIDAD DE LONGITUD VARIABLE
    00000000              00
    00000040              40
    0000007F              7F
    00000080             81 00
    00002000             C0 00
    00003FFF             FF 7F
    00004000           81 80 00
    00100000           C0 80 00
    001FFFFF           FF FF 7F
    00200000          81 80 80 00
    08000000          C0 80 80 00
    0FFFFFFF          FF FF FF 7F

Una cantidad de longitud variable (VLQ) es un código universal que utiliza 
un número arbitrario de octetos binarios (bytes de ocho bits) para 
representar un número entero arbitrariamente grande. Se definió para su 
uso en el formato de archivo estándar MIDI[1] para ahorrar espacio 
adicional para un sistema con recursos limitados y también se utiliza 
en el formato de música extensible posterior (XMF). Una VLQ es esencialmente 
una representación en base 128 de un número entero sin signo con la adición 
del octavo bit para marcar la continuación de los bytes. Mira el ejemplo a 
continuación.

	Int:    16384
	IntHex: 0x00004000
	IntBin: 00000000 00000000 01000000 00000000
	VLQHex: 0x81 0x80 0x00
	VLQBin: 00000000 10000001 10000000 00000000

Digamos que quiero representar el número 3435 en VLQ. 3435 en binario es 
110101101011. No podemos ajustarlo en un byte. Entonces, lo dividiremos 
desde el final en bloques de 7 bits.

    Sépteto	7	6	5	4	3	2	1
    #1		1	1	0	1	0	1	1
    #2		0	0	1	1	0	1	0

Ahora agregamos un bit de 1 a todos menos al último para indicar que 
sigue un octeto y agregamos un bit de 0 al último, señalando el octeto 
final.

    Octeto   8	7	6	5	4	3	2	1
    #1      0	1	1	0	1	0	1	1
    #2      1	0	0	1	1	0	1	0

Finalmente, los concatenamos, primero el octeto más significativo, en

Codificado: 10011010 01101011  En Hexadecimal: 0x9A 0x6B

*Recursos* *Adicionales:*

- [[https://en.wikipedia.org/wiki/Variable-length_quantity][https://en.wikipedia.org/wiki/Variable-length_quantity]]
- [[https://blogs.infosupport.com/a-primer-on-vlq/][https://blogs.infosupport.com/a-primer-on-vlq/]]

*Para* *una* *excelente* *implementación* *de* *este* *algoritmo,* *mira* *aquí:*

- [[https://github.com/go-audio/midi/blob/master/varint.go][https://github.com/go-audio/midi/blob/master/varint.go]]

.play algorithms/fun/vlq.go