Constantes
Uno de los aspectos más singulares de Go es cómo el lenguaje implementa las constantes.

* Constantes

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Ver el video]]
- Si necesita asistencia financiera, utilice nuestro [[https://www.ardanlabs.com/scholarship/][Formulario de becas]]

Uno de los aspectos más singulares de Go es cómo el lenguaje implementa las constantes. 
Las reglas para las constantes en la especificación del lenguaje son únicas en Go. 
Proporcionan la flexibilidad que Go necesita para hacer que el código que escribimos sea 
legible e intuitivo mientras se mantiene la seguridad de tipos. 

Las constantes pueden ser tipadas o no tipadas. Cuando una constante no está tipada, 
se considera de un tipo. Las constantes de un tipo pueden ser convertidas implícitamente 
por el compilador. Todo esto sucede en tiempo de compilación y no en tiempo de ejecución.

** Revisión de Código

- *Ejemplo* *1:* Declarar e inicializar constantes
- *Ejemplo* *2:* Sistema de tipo paralelo (Kind) (falta)
- *Ejemplo* *3:* iota			
- *Ejemplo* *4:* Conversión implícita

.play constants/example1.go
.play constants/example2.go
.play constants/example3.go
.play constants/example4.go

    const ui = 12345     // tipo: integer
    const uf = 3.141592  // tipo: floating-point

Las constantes numéricas no tipadas tienen una precisión de 256 bits según 
lo establecido por la especificación. Están basadas en un tipo.

    const ti int     = 12345     // tipo: int
    const tf float64 = 3.141592  // tipo: float64

Las constantes tipadas todavía usan el sistema de tipo constante, pero su 
precisión está restringida.

    const myUint8 uint8 = 1000 // Error del compilador: la constante 1000 desborda uint8

Esto no funciona porque el número 1000 es demasiado grande para almacenarse en un uint8.

    var answer = 3 * 0.333  // float64 = KindFloat(3) * KindFloat(0.333)

La aritmética constante admite el uso de diferentes tipos de constantes. La Promoción 
de tipo se utiliza para manejar estos diferentes escenarios. Todo esto sucede 
implícitamente. La variable answer en este ejemplo será de tipo float64 y representará 
0.999 con una precisión de 64 bits.

    const third = 1 / 3.0  // KindFloat = KindFloat(1) / KindFloat(3.0)

La tercera constante será de tipo float y representará 1/3 con una precisión de 256 bits.

    const zero = 1 / 3  // KindInt = KindInt(1) / KindInt(3)

La constante zero será de tipo entero y se establecerá en 0 ya que la división entera no 
tiene resto.

    const one int8 = 1
    const two = 2 * one  // int8(2) * int8(1)

Este es un ejemplo de aritmética constante entre constantes tipadas y no tipadas. 
En este caso, una constante de tipo se promociona sobre una constante de tipo. 
La constante two será de tipo int8 y se establecerá en 2.

    const maxInt = 9223372036854775807

Este es el valor máximo de un entero para un entero de 64 bits.

    const bigger = 9223372036854775808543522345

La constante bigger es un valor mucho más grande que un entero de 64 bits, pero puede 
almacenarse en una constante de tipo entero ya que las constantes de tipo entero no 
están limitadas a 64 bits de precisión.

    const bigger int64 = 9223372036854775808543522345

Error del compilador:

    la constant 9223372036854775808543522345 desborda int64

Sin embargo, si bigger fuera una constante de tipo int64, esto no se compilaría.

** IOTA

IOTA proporciona soporte para establecer constantes enteras sucesivas. Es posible 
que el nombre provenga de la función entera ⍳ del lenguaje de programación APL. 
En APL, la función ⍳ (representada con la novena letra del alfabeto griego, iota) 
se usa para crear una matriz de enteros consecutivos basada en cero de una longitud 
especificada.

    const (
        A1 = iota  // 0 : Comienza en 0
        B1 = iota  // 1 : Incrementa en 1
        C1 = iota  // 2 : Incrementa en 1
    )
    fmt.Println(A1, B1, C1)

Salida:

    0 1 2

La palabra clave iota funciona dentro de un bloque constante y comienza con el valor 0. 
Luego, para cada constante sucesiva declarada en el bloque, iota se incrementa en 1.

    const (
        A2 = iota  // 0 : Comienza en 0
        B2         // 1 : Incrementa en 1
        C2         // 2 : Incrementa en 1
    )
    fmt.Println(A2, B2, C2)

Salida:

    0 1 2

No es necesario repetir el uso de la palabra clave iota. La naturaleza sucesiva de 
las constantes enteras se asume una vez aplicada.

    const (
        A3 = iota + 1  // 1 : 0 + 1
        B3             // 2 : 1 + 1
        C3             // 3 : 2 + 1
    )
    fmt.Println(A3, B3, C3)

Salida:

    1 2 3

Si no deseas aplicar un patrón matemático, puedes realizar alguna operación matemática 
y la operación se vuelve a aplicar con un valor creciente de iota.

    const (
        Ldate= 1 << iota  //  1 : Desplaza 1 a la izquierda 0.  0000 0001
        Ltime             //  2 : Desplaza 1 a la izquierda 1.  0000 0010
        Lmicroseconds     //  4 : Desplaza 1 a la izquierda 2.  0000 0100
        Llongfile         //  8 : Desplaza 1 a la izquierda 3.  0000 1000
        Lshortfile        // 16 : Desplaza 1 a la izquierda 4.  0001 0000
        LUTC              // 32 : Desplaza 1 a la izquierda 5.  0010 0000
    )

    fmt.Println(Ldate, Ltime, Lmicroseconds, Llongfile, Lshortfile, LUTC)

Notas:

    1 2 4 8 16 32

Puedes usar esta característica como lo hace el paquete Log para establecer banderas. 
En este caso, se aplican operaciones de bits con valores crecientes de iota para 
calcular los valores de las banderas.

** Notas

- Las constantes no son variables.
- Solo existen durante la compilación.
- Las constantes no tipadas pueden ser convertidas implícitamente, mientras que las constantes y variables tipadas no pueden.
- Piensa en las constantes no tipadas como teniendo una "Kind", no un "Type".
- Aprende sobre las conversiones explícitas e implícitas.
- Observa el poder de las constantes y su uso en la biblioteca estándar.

** Lecturas Adicionales

- [[https://golang.org/ref/spec#Constants][Constants specification]]    
- [[https://blog.golang.org/constants][Constants]] - Rob Pike    
- [[https://www.ardanlabs.com/blog/2014/04/introduction-to-numeric-constants-in-go.html][Introduction To Numeric Constants In Go]] - William Kennedy    
		
* Ejercicios

Utiliza la plantilla como punto de partida para completar los ejercicios. Se proporciona una posible solución.

** Ejercicio 1

*Parte* *A:* Declara una constante no tipada y una tipada y muestra sus valores.

*Parte* *B:* Divide dos constantes literales en una variable tipada y muestra el valor.

.play constants/exercise1.go
.play constants/answer1.go
