Variables
Las variables representan el corazón del lenguaje y proporcionan la habilidad de leer de y escribir a memoria.

* Variables

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Ve el Vídeo]]
- Necesitas de Ayuda Financiera, Utiliza Nuestro [[https://www.ardanlabs.com/scholarship/][Formulario de Becas]]

Las variables representan el corazón del lenguaje y proporcionan la habilidad de leer de
y escribir a memoria. En Go, el acceso a memoria es "type safe". Ésto significa que el compilador
se toma los tipos muy en serio y no nos permitirá utilizar variables fuera del ámbito
en el que fueron declaradas.

** Revisión de Código

- *Ejemplo* *1*: Programa de ejemplo que muestra cómo declarar variables.

.play variables/example1.go

** Tipos Básicos
Los tipos proporcionan integridad y legibilidad haciendo 2 preguntas:

- ¿Cuánta memoria se asigna? (por ejemplo, 1, 2, 4, 8 bytes)
- ¿Qué representa la memoria? (por ejemplo, int, uint, bool...) 

Los tipos pueden especificar una precisión, tales como int32 o int64:

- uint8 representa un entero sin signo con 1 byte de asignación.
- int32 representa un entero con signo con 4 bytes de asignación. Cuando declaras un tipo
utilizando un tipo que no especifica la precisión (uint, int), el tamaño del valor está basado en la
arquitectura utilizada para construir el programa:

- Arquitecturas de 32 bit: int representa un entero con signo con 4 bytes de asignación.
- Arquitecturas de 64 bit: int representa un entero con signo con 8 bytes de asignación.

** Tamaño de Palabra

El tamaño de palabra representa la cantidad de memoria asignada requerida para almacenar enteros
y punteros para una arquitectura dada. Por ejemplo:

- Arquitecturas de 32 bit: el tamaño de palabra es 4 bytes de asignación de memoria.
- Arquitecturas de 64 bit: el tamaño de palabra es 8 bytes de asignación de memoria.

Ésto es importante porque Go tiene estructuras de datos internas (mapas, channels, slices,
interfaces, y funciones) que almacenan enteros y punteros. El tamaño de estas estructuras
de datos se basará en la arquitectura utilizada para construir el programa.

En Go, la candidad de memoria asignada para un valor de tipo int, un puntero, o una palabra
siempre será el mismo para una misma arquitectura.

** Concepto del Valor Cero
Cada valor que construyes en Go es inicializado al menos en su estado de valor cero,
a menos que especifiques el valor de inicialización al construirlo. El valor cero es la configuración
de cada bit en cada byte como cero.

This is done for data integrity and it’s not free. It takes time to push electrons
through the machine to reset those bits, but you should always take integrity over
performance.
Ésto se hace por la integridad del dato, y no es gratis. Lleva tiempo empujar electrones
a través de la máquina para resetear esos bits, pero siempre deberías preferir integridad sobre
rendimiento.

    Tipo              Valor Cero
    Booleano          false
    Entero            0
    Flotante          0
    Complejo          0i
    Cadena            "" (cadena vacía)
    Puntero           nil

** Declaración e Inicialización
La palabra reservada var puede utilizarse para contruir valores a su estado de valor cero, para todos los tipos.

    var a int
    var b string
    var c float64
    var d bool

    fmt.Printf("var a int \t %T [%v]\n", a, a)
    fmt.Printf("var b string \t %T [%v]\n", b, b)
    fmt.Printf("var c float64 \t %T [%v]\n", c, c)
    fmt.Printf("var d bool \t %T [%v]\n\n", d, d)

Salida:

    var a int    	int [0]
    var b string 	string []
    var c float64	float64 [0]
    var d bool   	bool [false]

Las cadenas de caracteres utilizan UTF8 como conjunto de caracteres, pero en realidad son una colección de bytes.

Una cadena de caracteres en Go es una estructura de datos interna compuesta de dos palabras:

- La primera palabra representa un puntero al arreglo que da soporte a los bytes.
- La segunda palabra representa la longitud o el número de bytes en el arreglo de soporte.
- Si la cadena se asigna a su estado de valor cero, entonces la primera palabra es nil y la segunda palabra es 0.

Utilizando el operador corto de declaración de variable, puedes declarar, contruir,
e inicializar un valor todo al mismo tiempo.

    aa := 10       // int [10]
    bb := "hola"   // string [hola]
    cc := 3.14159  // float64 [3.14159]
    dd := true     // bool [true]

    fmt.Printf("aa := 10 \t %T [%v]\n", aa, aa)
    fmt.Printf("bb := \"hola\" \t %T [%v]\n", bb, bb)
    fmt.Printf("cc := 3.14159 \t %T [%v]\n", cc, cc)
    fmt.Printf("dd := true \t %T [%v]\n\n", dd, dd)

Salida:

    aa := 10         int [10]
    bb := "hola"     string [hola]
    cc := 3.14159    float64 [3.14159]
    dd := true       bool [true]

** Conversión vs Casting

Go no tiene casting, pero sí conversión. En lugar de decirle al compilador que mapee un
conjunto de bytes a una representación diferente, los bytes necesitan ser copiados al nuevo
lugar de memoria para la nueva representación.

    aaa := int32(10)
    fmt.Printf("aaa := int32(10) %T [%v]\n", aaa, aaa)

    Salida:
    aaa := int32(10) int32 [10]

Go tiene un paquete en la librería estándar llamado unsafe, por si necesitas realizar
una operación de casting. En realidad deberías evitarlo y ser honesto contigo mismo
sabiendo por qué estás considerando su uso. Realizar una conversión proporciona el nivel más alto
de integridad para este tipo de operaciones.

** Notas

- El propósito de cualquier programa y de cualquier parte de esos programas es transformar datos de una a otra forma.
- El código principalmente asigna, lee y escribe a memoria.
- Comprender el tipado es crucial para escribir buen código y entenderlo.
- Si no comprendes los datos, entonces no comprendes el problema.
- Comprendes mejor el problema si comprendes los datos.
- Cuando las variables son declaradas a su valor cero, utiliza la palabra reservada var.
- Cuando las variables son declaradas e inicializadas, utiliza el operador corto de declaración de variable.

** Lecturas Extra

- [[http://golang.org/ref/spec#Boolean_types][Tipos Básicos]]    
- [[https://golang.org/doc/effective_go.html#variables][Variables]]    
- [[https://www.ardanlabs.com/blog/2013/08/gustavos-ieee-754-brain-teaser.html][Gustavo's IEEE-754 Brain Teaser]] - William Kennedy    
- [[https://www.youtube.com/watch?v=sFUSP8Au_PE][What's in a name]]    
- [[http://arcanesentiment.blogspot.com/2015/01/a-brief-history-of-type.html][A brief history of “type”]] - Arcane Sentiment    

* Ejercicios

Use the template as a starting point to complete the exercises. A possible solution is provided.
Utiliza la plantilla como punto de partida para completar los ejercicios. Una posible solución es proporcionada.

** Ejercicio 1

*Parte* *A:* Declara tres variables que estén inicializadas a su valor cero y
tres declaradas con su valor literal. Declara variables de tipo cadena, entero y booleano.
Muestra los valores de esas variables.

*Parte* *B:* Declara una nueva variable de tipo float32 e inicializa la variable
convirtiendo el valor literal de Pi (3.14).

.play variables/exercise1.go
.play variables/answer1.go
