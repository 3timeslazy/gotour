Variabeln
Variabeln sind das Herzstück der Sprache, sie können von Speicher lesen oder diesen beschreiben.

* Variabeln

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Schau das Video]]
- Brauchst Du finanzielle Hilfe [[https://www.ardanlabs.com/scholarship/][Stipendium]]

Variabeln sind das Herzstück der Sprache, sie können von Speicher lesen oder diesen beschreiben.
In Go ist der Zugriff auf Speicher type safe, das heisst der Compiler nimmt Types ernst und erlaubt es nicht, diese ausserhalb des Scopes als in dem sie definiert wurden zu verwenden.

** Code Review

- *Beispiel* *1*: Beispielprogramm das zeigt wie man Variabeln deklariert.

.play variables/example1.go

** Built-in Types
Types sind stellen 2 wichtige Fragen bezüglich Integrität und Lesbarkeit:

- Wieviel Memory wird alloziert (zB: 1, 2, 4, 8 bytes)
- Was wird im Memory repräsentiert (zB: int, uint, bool, ...)

Types können spezifisch für eine Präzision sein (int32 oder int64)

- uint8 ist ein usigned integer mit 1 byte Memory allozier
- int32 ist ein signed integer mit 4 bytes Memory alloziert.

Wenn Du einen Type mit einem non-precision basierten Typen deklarierst (unit, int) wir die Grösse des Wertes aufgrund der Rechner-Architektur gesetzt:

- 32 bit arch: int ist signed mit 4 bytes Memory-Allozierung
- 64 bit arch: int ist signed mit 8 bytes Memory-Allozierung

** Wort Grösse

Die Wort-Grösse repräsentiert die Anzahl Memory Allozierung die benötigt wird um integers und pointers für eine Architektur zu speichern.
Zum Beispiel


- 32 bit arch: Wort Grösse ist 4 bytes Memory-Allozierung
- 64 bit arch: Wort GRösse ist 8 bytes Memory-Allozierung


Dies ist wichtig weil Go interne Datenstrukturen besitzt (maps, channels, slices, interfaces und functions) die integers und pointers speichern. Die Grösse dieser Daten-Strukturen basiert auf der Architektur die benutz wird umd das Programm zu builden
In Go, die Anzahl Memory die für das Allozieren eines Werts vom Typ int, pointer oder word ist immer dieselbe auf derselben Architektur.

** Zero Value Konzept
Jeder Wert der in Go gesetzt wird, wird mindestens mit seinem zero value initialisiert, es sei denn der Wert wird bei der Initialisierung explizit gesetzt. Der zero value ist das Setzen von jedem bit in jedem Byte auf Null.

Dies ist so wegen der Daten-Integrität und ist nicht gratis. Es braucht Zeit um Elektronen durch die Maschine zu senden um diese bits zu resetten, aber Integrität ist immer wichtiger als Performance.


    Type               Zero Value
    Boolean            false
    Integer            0
    Float              0
    Complex            0i
    String             "" (empty)
    Pointer            nil

** Deklaration und Initialisierung 
Das keyword var kann benutzt werden um Werte mit ihrem zero value zu initialisieren.

    var a int
    var b string
    var c float64
    var d bool

    fmt.Printf("var a int \t %T [%v]\n", a, a)
    fmt.Printf("var b string \t %T [%v]\n", b, b)
    fmt.Printf("var c float64 \t %T [%v]\n", c, c)
    fmt.Printf("var d bool \t %T [%v]\n\n", d, d)

Output:

    var a int    	int [0]
    var b string 	string []
    var c float64	float64 [0]
    var d bool   	bool [false]

String benutzen das UTF8 character set, aber sind in Wirklichkeit nur eine Kollektion von bytes.

Ein string ist eine zwei-word interne Datenstruktur in Go:

- Das erste Wort repräsentiert einen Pointer zu einem backing array aus bytres
- Das zweite Wort repräsentiert die Länge bzw. Anzahl bytes im backing array
- Wenn ein string als zero value initialisiert wird, ist das erste word nil und das zweite word 0

Mit dem short variable decclaration operator, kann man gleichzeitig einen Wert deklarieren, konstruieren und initialisieren.

    aa := 10       // int [10]
    bb := "hello"  // string [hello]
    cc := 3.14159  // float64 [3.14159]
    dd := true     // bool [true]

    fmt.Printf("aa := 10 \t %T [%v]\n", aa, aa)
    fmt.Printf("bb := \"hello\" \t %T [%v]\n", bb, bb)
    fmt.Printf("cc := 3.14159 \t %T [%v]\n", cc, cc)
    fmt.Printf("dd := true \t %T [%v]\n\n", dd, dd)

Output:

    aa := 10         int [10]
    bb := "hello"    string [hello]
    cc := 3.14159    float64 [3.14159]
    dd := true       bool [true]

** Konversion vs Casting

In Go gibt es kein casting, aber conversion. Anstatt dem Kompiler mitzuteilen er soll ein byte-set in einer anderen Representation mappen, werden die bytes im Memory für die neue Representation an einen neuen Ort im Memory kopiert.

    aaa := int32(10)
    fmt.Printf("aaa := int32(10) %T [%v]\n", aaa, aaa)

    Output:
    aaa := int32(10) int32 [10]

Go hat ein package in der standard library namens unsafe für den Fall dass man eine casting Operation ausführen will. Dies sollte vermieden werden. Das Durchführen einer conversion ist das höchste Level an Datenintegrität für solche Operationen.


** Notizen
- Der Zweck von allen Programmen ist es Daten von einer Form in eine andere zu transformieren
- Code tut in erster Linie folgendes: Memory allozieren, lesen und schreiben
- Das verstehen von Typen ist missionskritisch um guten Code zu schreiben und zu verstehen
- Wenn Du die Daten nicht verstehst, verstehst Du das Problem nicht
- Mit dem verstehen der Daten, verstehst Du das Problem besser
- Wenn Variabeln mit ihrem zero value deklariert werden, benutze das var keyword
- Wenn Variabeln deklariert und initialisiert werden, benutze die short variable declaration


** Extra Reading

- [[http://golang.org/ref/spec#Boolean_types][Built-In Types]]    
- [[https://golang.org/doc/effective_go.html#variables][Variables]]    
- [[https://www.ardanlabs.com/blog/2013/08/gustavos-ieee-754-brain-teaser.html][Gustavo's IEEE-754 Brain Teaser]] - William Kennedy    
- [[https://www.youtube.com/watch?v=sFUSP8Au_PE][What's in a name]]    
- [[http://arcanesentiment.blogspot.com/2015/01/a-brief-history-of-type.html][A brief history of “type”]] - Arcane Sentiment    

* Aufgaben
Benutze das Template als Startpunkt um die Aufgabe zu erfüllen. Eine mögliche Antwort wird bereitgestellt.

** Aufabe 1

*Teil* *A:* Deklariere 3 Variabeln die mit ihrem zero value initialisiert werden und 3 Variabeln mit einem expliziten Wert. Deklariere Variabeln vom Type string, int und bool.
Zeige die Werte der Variabeln an.

*Part* *B:*
Deklariere eine neue Variabel vom type float32 und initialisiere die Variabel indem Du den Wert auf Pi (3.14) setztst.

.play variables/exercise1.go
.play variables/answer1.go
