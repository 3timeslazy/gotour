Einbettung
Die Einbettung von Typen stellt den letzten Teil der gemeinsamen Nutzung und Wiederverwendung von Zustand und Verhalten zwischen Typen dar.

* Einbettung

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Das Video ansehen]]
- Benötigen Sie finanzielle Unterstützung, nutzen Sie unser [[https://www.ardanlabs.com/scholarship/][Stipendienformular]]

Die Einbettung von Typen stellt den letzten Teil der gemeinsamen Nutzung und Wiederverwendung von Zustand und Verhalten
zwischen Typen. Durch die Verwendung von Inner Type Promotion kann auf die Felder und Methoden eines inneren Typs
Methoden eines inneren Typs kann durch Referenzen des äußeren Typs direkt zugegriffen werden.

** Code-Überprüfung

- *Beispiel* *1:* Felder deklarieren
- *Beispiel* *2:* Einbettung von Typen
- *Beispiel* *3:* Eingebettete Typen und Schnittstellen
- *Beispiel* *4:* Äußere und innere Typschnittstellenimplementierungen
	
.play embedding/example1.go
.play embedding/example2.go
.play embedding/example3.go		   
.play embedding/example4.go


** Mechanik der Einbettung

Dieses erste Beispiel zeigt keine Einbettung, sondern nur die Deklaration von zwei struct
Typen, die zusammen als ein Feld von einem Typ zum anderen arbeiten.

    Typ user struct {
        name string
        email string
    }

    Typ admin struct {
        person user // NOT Embedding
        level string
    }

Dies ist die Einbettung.

    Typ user struct {
        name string
        email string
    }

    Typ admin struct {
        user // Wert Semantische Einbettung
        level string
    }

Das Personenfeld wird entfernt, und es bleibt nur der Typname übrig. Sie können auch einen
Typ mit Zeiger-Semantik einbetten.

    Typ user struct {
        name string
        email string
    }

    Typ admin struct {
        *user // Semantische Einbettung von Zeigern
        level string
    }

In diesem Fall wird ein Zeiger des Typs eingebettet. In beiden Fällen erfolgt der Zugriff auf den
eingebetteten Wertes erfolgt durch die Verwendung des Typnamens.

Die beste Art, über die Einbettung nachzudenken, ist, den Benutzertyp als einen inneren Typ und
Admin als einen äußeren Typ zu betrachten. Diese Beziehung zwischen innerem und äußerem Typ ist das Magische
denn mit der Einbettung kann alles, was mit dem inneren Typ zusammenhängt (sowohl Felder als auch Methoden)
auf den äußeren Typ übertragen werden kann.

    Typ user struct {
        name string
        email string
    }

    func (u *user) notify() {
        fmt.Printf("Sending user email To %s<%s>\n",
            u.name,
            u.email)
    }

    Typ admin struct {
        *user // Semantische Einbettung von Zeigern
        level string
    }

    func main() {
        ad := admin{
            Benutzer: &Benutzer{
                name: "john smith",
                email: "john@yahoo.com",
            },
            level: "super",
        }

        ad.user.notify()
        ad.notify() // Äußere Form der Werbung
    }

Ausgabe:

    Senden einer Benutzer-E-Mail an john smith<john@yahoo.com>
    Senden einer Benutzer-E-Mail an john smith<john@yahoo.com>

Fügen Sie einmal eine Methode namens notify für den Benutzertyp und dann eine kleine Hauptfunktion hinzu.
Sie sehen, dass die Ausgabe dieselbe ist, egal ob Sie die notify-Methode über den inneren
Zeigerwert direkt oder über den Wert des äußeren Typs aufrufen. Die für den Benutzertyp deklarierte notify-Methode
deklarierte notify-Methode ist direkt über den Wert des Typs admin zugänglich.

Auch wenn dies wie Vererbung aussieht, müssen Sie vorsichtig sein. Hier geht es nicht um die Wiederverwendung
Zustand, sondern um die Förderung von Verhalten.

    Typ notifier Schnittstelle {
        notify()
    }

    func sendNotification(n notifier) {
        n.notify()
    }

Jetzt fügen Sie eine Schnittstelle und eine polymorphe Funktion hinzu, die jeden konkreten Wert akzeptiert
akzeptiert, der den gesamten Methodensatz des Verhaltens implementiert, der durch die Schnittstelle notifier definiert ist.
Das ist einfach eine Methode namens notify.

Aufgrund der Einbettung und Heraufstufung implementieren Werte vom Typ admin nun die Schnittstelle Notifier
Schnittstelle.

    func main() {
        ad := admin{
            Benutzer: &Benutzer{
                name: "john smith",
                email: "john@yahoo.com",
            },
            level: "super",
        }

        sendNotification(&ad)
    }

Ausgabe:

    Senden einer Benutzer-E-Mail an john smith<john@yahoo.com>

Sie können die Adresse des Admin-Wertes an die polymorphe Funktion senden, da
die Einbettung das Benachrichtigungsverhalten bis zum Admin-Typ fördert.

    Typ admin struct {
        *user // Semantische Einbettung von Zeigern
        level string
    }

    func (a *admin) notify() {
        fmt.Printf("Sending admin Email To %s<%s>\n",
            a.name,
            a.email)
    }

Wenn der äußere Typ eine Methode implementiert, die bereits durch den inneren Typ implementiert wurde,
findet die Beförderung nicht statt.

    func main() {
        ad := admin{
            Benutzer: &Benutzer{
                name: "john smith",
                email: "john@yahoo.com",
            },
            level: "super",
        }

        sendNotification(&ad)
    }

Ausgabe:
    
    Senden einer Admin-E-Mail an john smith<john@yahoo.com>

Sie sehen, dass die Methode des äußeren Typs jetzt ausgeführt wird.

** Anmerkungen

- Durch die Einbettung von Typen können wir den Zustand oder das Verhalten zwischen Typen gemeinsam nutzen.
- Der innere Typ verliert nie seine Identität.
- Dies ist keine Vererbung.
- Durch Promotion kann auf Felder und Methoden des inneren Typs über den äußeren Typ zugegriffen werden.
- Der äußere Typ kann das Verhalten des inneren Typs außer Kraft setzen.

** Extra Lesen

- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Methoden, Interfaces und eingebettete Typen in Go]] - William Kennedy
- [[https://rakyll.org/typesystem/][Einbettung ist keine Vererbung]] - JBD

* Übungen

Verwenden Sie die Vorlage als Ausgangspunkt, um die Aufgaben zu lösen. Eine mögliche Lösung ist angegeben.

** Übung 1

Bearbeiten Sie den Code der Vorlage. Fügen Sie einen neuen Typ CachingFeed hinzu, der Feed einbettet und
die Fetch-Methode überschreibt.

.play embedding/exercise1.go
.play embedding/answer1.go
