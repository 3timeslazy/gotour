Gruppierung mit Typen
Es ist wichtig, sich daran zu erinnern, dass in Go die Konzepte der Untertypisierung oder Unterklassenbildung nicht wirklich existieren und diese Entwurfsmuster vermieden werden sollten.

* Gruppierung mit Typen

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Das Video ansehen]]
- Benötigen Sie finanzielle Unterstützung, nutzen Sie unser [[https://www.ardanlabs.com/scholarship/][Stipendienformular]]

Es ist wichtig, sich daran zu erinnern, dass in Go die Konzepte der Sub-Typisierung oder Sub-Klassifizierung
nicht wirklich existieren und diese Entwurfsmuster vermieden werden sollten.

** Code-Überprüfung

- *Beispiel* *1:* Gruppierung nach Zustand
- *Beispiel* *2:* Gruppierung nach Verhalten

.play composition/grouping/example1.go
.play composition/grouping/example2.go

** Gruppierung verschiedener Datentypen

Es ist wichtig, sich daran zu erinnern, dass in Go die Konzepte der Sub-Typisierung oder Sub-Klassifizierung
nicht wirklich existieren und diese Entwurfsmuster vermieden werden sollten.

Das Folgende ist ein Anti-Muster, das Sie nicht befolgen oder umsetzen sollten.

    Typ Tier struct {
        Name string
        IsMammal bool
    }

Der Typ Tier wird als Basistyp deklariert, der versucht, Daten zu definieren, die
allen Tieren gemeinsam sind. Sie versuchen auch, einem Tier ein gemeinsames Verhalten zu
Tier auch ein gemeinsames Verhalten zu geben.

    func (a *Tier) Speak() {
        fmt.Println("UGH!",
        "Mein Name ist", a.Name, ", es ist", a.IsMammal, "Ich bin ein Säugetier")
    }

Die meisten Tiere haben die Fähigkeit, auf die eine oder andere Weise zu sprechen. Der Versuch, dieses
dieses allgemeine Verhalten nur auf ein Tier anzuwenden, macht keinen Sinn. An diesem
haben Sie keine Ahnung, welches Geräusch dieses Tier macht, also schreiben Sie UGH.

    Typ Hund struct {
        Tier
        PackFactor int
    }

Jetzt beginnen die wirklichen Probleme. Ich versuche, mit Hilfe von Embedding einen Hund zu machen
alles zu machen, was ein Tier ist, und noch mehr. Oberflächlich betrachtet scheint das zu funktionieren, aber es
wird es Probleme geben. Abgesehen davon hat ein Hund eine bestimmte Art zu sprechen.

    func (d *Dog) Speak() {
        fmt.Println("Wuff!",
            "Mein Name ist", d.Name,
            ", es ist", d.IsMammal,
            "Ich bin ein Säugetier mit einem Packfaktor von", d.PackFactor)
    }

In der Implementierung der Speak-Methode können Sie UGH gegen Woof austauschen. Dies ist
spezifisch dafür, wie ein Hund spricht.

    Typ Katze struct {
        Tier
        SteigFaktor int
    }

Wenn ich einen Hund haben will, der ein Tier repräsentiert, dann musst du eine Katze haben.
Durch die Einbettung ist eine Katze alles, was ein Tier ist, und noch mehr.

    func (c *Katze) Sprechen() {
        fmt.Println("Miau!",
            "Mein Name ist", c.Name,
            ", es ist", c.IsMammal,
            "Ich bin ein Säugetier mit einem Kletterfaktor von", c.ClimbFactor)
    }

Bei der Implementierung der Speak-Methode können Sie UGH gegen Meow austauschen. Diese
ist spezifisch dafür, wie eine Katze spricht.

Alles scheint in Ordnung zu sein, und es sieht so aus, als würde die Einbettung die gleiche Funktionalität bieten
Funktionalität wie die Vererbung in anderen Sprachen. Dann versucht man weiterzugehen und
Hunde und Katzen nach der Tatsache zu gruppieren, dass sie eine gemeinsame DNA haben, nämlich die eines Tieres.

    animals := []Tier{
        Hund{
            Tier: Tier{
                Name: "Fido",
                IsMammal: true,
            },
            PackFactor: 5,
        },
    
        Katze{
            Tier: Tier{
                Name: "Milo",
                IsMammal: true,
            },
            ClimbFactor: 4,
        },
    }

    for _, animal := range animals {
        animal.Speak()
    }

Wenn Sie dies versuchen, beschwert sich der Compiler, dass ein Hund und eine Katze kein Tier sind
sind, und das ist richtig. Einbetten ist nicht dasselbe wie Vererbung, und das ist das Muster, das ich
von dem ich mich fernhalten muss. Ein Hund ist ein Hund, eine Katze eine Katze, und ein Tier ein Tier. I
kann Hunde und Katzen nicht weitergeben, als wären sie Tiere, denn das sind sie nicht.

Diese Art von Mechanik ist auch nicht sehr flexibel. Sie erfordert eine Konfiguration durch den
Entwickler, und wenn Sie keinen Zugang zum Code haben, können Sie keine Konfigurationsänderungen
vornehmen.

Wenn wir auf diese Weise nicht eine Sammlung von Hunden und Katzen erstellen können, wie können wir dann
das in Go? Es geht nicht um Gruppierung durch gemeinsame DNA, sondern um Gruppierung
durch gemeinsames Verhalten. Das Verhalten ist der Schlüssel.

    Typ Speaker Schnittstelle {
        Speak()
    }

Wenn Sie eine Schnittstelle verwenden, können Sie den gemeinsamen Methodensatz des Verhaltens definieren, den ich
verschiedene Datentypen gruppieren möchte.

    speakers := []Speaker{
        &Hund{
            Tier: Tier{
                Name: "Fido",
                IsMammal: true,
            },
            PackFactor: 5,
        },
        &Katze{
            Tier: Tier{
                Name: "Milo",
                IsMammal: true,
            },
            ClimbFactor: 4,
        },
    }

    for _, speaker := range speakers {
        speaker.Speak()
    }

Im neuen Code können Sie nun Hunde und Katzen auf der Grundlage ihrer gemeinsamen
Verhalten gruppieren, nämlich die Tatsache, dass Hunde und Katzen sprechen können.

Tatsächlich ist der Typ "Animal" in Wirklichkeit eine Typverschmutzung, denn einen Typ zu deklarieren, nur um
einen Satz gemeinsamer Zustände zu teilen, ist ein Geruch und sollte vermieden werden.

    Typ Hund struct {
        Name string
        IsMammal bool
        PackFactor int
    }
    
    Typ Katze struct {
        Name string
        IsMammal bool
        SteigFaktor int
    }

In diesem speziellen Fall wäre es besser, wenn Sie den Typ Tier entfernen und die Felder
kopiert und in die Typen Hund und Katze eingefügt werden. Später werden Sie Hinweise auf bessere
Muster, die diese Szenarien ausschließen.

Hier sind die Codegerüche des ursprünglichen Codes:

- Der Typ Animal bietet eine Abstraktionsschicht für wiederverwendbare Zustände.
- Das Programm muss nie einen Wert vom Typ Tier erstellen oder nur verwenden.
- Die Implementierung der Methode "Speak" für den Typ "Animal" ist verallgemeinert.
- Die Methode "Speak" für den Typ "Animal" wird nie aufgerufen werden.

Richtlinien zur Deklaration von Typen:

- Deklarieren Sie Typen, die etwas Neues oder Einzigartiges darstellen.
- Erstellen Sie keine Aliasnamen, nur um die Lesbarkeit zu erhöhen.
- Überprüfen Sie, dass ein Wert eines beliebigen Typs selbständig erstellt oder verwendet wird.
- Betten Sie Typen nicht ein, weil Sie den Zustand brauchen, sondern weil wir das Verhalten brauchen.
- Wenn Sie nicht über das Verhalten nachdenken, binden Sie sich selbst in ein Design ein, das Sie in der Zukunft nicht ohne kaskadierende Codeänderungen erweitern können.
- Fragetypen, die Aliase oder Abstraktionen für einen bestehenden Typ sind.
- Fragetypen, deren einziger Zweck es ist, einen gemeinsamen Satz von Zuständen zu teilen.

** Entwerfen Sie nicht mit Schnittstellen

Leider versuchen zu viele Entwickler, Probleme zunächst abstrakt zu lösen.
Sie konzentrieren sich sofort auf die Schnittstellen, was zu einer Schnittstellenverschmutzung führt. Als
Entwickler existiert man in einem von zwei Modi: als Programmierer und dann als Ingenieur.

Wenn Sie programmieren, konzentrieren Sie sich darauf, ein Stück Code zum Laufen zu bringen. Versuchen Sie
das Problem zu lösen und Mauern zu durchbrechen. Beweisen, dass meine ursprünglichen Ideen funktionieren. Das ist
alles, worum man sich kümmert. Diese Programmierung sollte im Konkreten erfolgen und ist niemals
produktionsreif.

Sobald Sie einen Prototyp des Codes haben, der das Problem löst, müssen Sie in den
Entwicklungsmodus wechseln. Sie müssen sich darauf konzentrieren, wie Sie den Code auf Mikroebene schreiben, um
Daten-Semantik und Lesbarkeit, dann auf Makroebene auf mentale Modelle und
Wartbarkeit. Sie müssen sich auch auf Fehler und Fehlerzustände konzentrieren.

Diese Arbeit wird in einem Refactoring-Zyklus durchgeführt. Refaktorierung für Lesbarkeit, Effizienz,
Abstraktion und Testbarkeit. Die Abstraktion ist nur eine der wenigen Refactors, die
durchgeführt werden müssen. Dies funktioniert am besten, wenn Sie mit einem Stück konkreten Code beginnen und
dann die benötigten Schnittstellen ENTDECKEN. Wenden Sie keine Abstraktionen an, wenn sie
absolut notwendig sind.

Jedes Problem, das Sie mit Code lösen, ist ein Datenproblem, für das ich Datentransformationen schreiben muss.
Transformationen zu schreiben. Wenn Sie die Daten nicht verstehen, verstehen Sie auch das Problem nicht. Wenn Sie
das Problem nicht verstehen, können Sie keinen Code schreiben. Wenn man mit einer konkreten
Lösung zu beginnen, die auf den konkreten Datenstrukturen basiert, ist entscheidend. Wie Rob Pike sagte,

"Daten dominieren. Wenn man die richtigen Datenstrukturen gewählt und die Dinge gut organisiert hat
gut organisiert hat, sind die Algorithmen fast immer selbstverständlich". - Rob Pike

Wann ist Abstraktion notwendig? Wenn Sie eine Stelle im Code sehen, an der sich die Daten
ändern könnten und Sie die daraus resultierenden Kaskadeneffekte minimieren wollen. I
Abstraktion kann helfen, den Code testbar zu machen, aber Sie sollten versuchen, dies möglichst zu vermeiden.
wenn möglich. Die besten testbaren Funktionen sind Funktionen, die Rohdaten entgegennehmen und
Rohdaten ausgeben. Es sollte keine Rolle spielen, woher die Daten kommen oder wohin sie gehen.

Beginnen Sie am Ende mit einer konkreten Lösung für jedes Problem. Auch wenn der größte Teil davon
nur Programmierung ist. Dann entdecken Sie die Schnittstellen, die für den Code unbedingt erforderlich sind.
den Code heute.

"Entwerfen Sie nicht mit Schnittstellen, entdecken Sie sie". - Rob Pike
