Entkopplung
Komposition geht über die Mechanik der Typeneinbettung hinaus und ist mehr als nur ein Paradigma.

* Entkopplung

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Das Video ansehen]]
- Benötigen Sie finanzielle Unterstützung, nutzen Sie unser [[https://www.ardanlabs.com/scholarship/][Stipendienformular]]

Der beste Weg, die Vorteile der Einbettung zu nutzen, ist das kompositorische Design
Muster. Es ist der Schlüssel zur Aufrechterhaltung der Stabilität Ihrer Software, da es die
Fähigkeit, sich an die kommenden Daten- und Transformationsänderungen anzupassen.

** Code-Überprüfung

- *Beispiel* *1:* Strukturelle Komposition
- *Beispiel* *2:* Entkopplung mit Interface
- *Beispiel* *3:* Interface-Zusammensetzung
- *Beispiel* *4:* Entkopplung mit Schnittstellenkomposition
- *Beispiel* *5:* Interface-Verschmutzung entfernen
- *Beispiel* *6:* Präzisere API


.play composition/decoupling/example1.go
.play composition/decoupling/example2.go
.play composition/decoupling/example3.go
.play composition/decoupling/example4.go
.play composition/decoupling/example5.go
.play composition/decoupling/example6.go

** Entkopplungsmechanik

Die Idee ist, größere Typen aus kleineren Typen zusammenzusetzen und sich auf die Zusammensetzung
des Verhaltens.

    Typ Xenia struct {
        Host string
        Timeout Zeit.Dauer
    }

    func (*Xenia) Pull(d *Data) error {
        switch rand.Intn(10) {
        Fall 1, 9:
            return io.EOF
        case 5:
            return errors.New("Fehler beim Lesen von Daten aus Xenia")
        default:
            d.Line = "Daten"
            fmt.Println("In:", d.Line)
            return nil
        }
    }

Der Xenia-Typ stellt ein System dar, aus dem Sie Daten ziehen müssen. Die Implementierung
ist nicht wichtig. Wichtig ist, dass die Methode Pull erfolgreich sein kann, fehlschlagen kann oder
keine Daten zum Ziehen hat.

    Typ Pillar struct {
        Host string
        Timeout Zeit.Dauer
    }

    func (*Pillar) Store(d *Data) error {
        fmt.Println("Out:", d.Line)
        return nil
    }

Der Pillar-Typ stellt ein System dar, in dem Sie Daten speichern müssen. Wichtig
wichtig ist, dass die Methode Store erfolgreich sein oder fehlschlagen kann.

Diese beiden Typen stellen eine primitive Codeschicht dar, die das Basisverhalten bietet
Verhalten bereitstellt, das zur Lösung des Geschäftsproblems des Abrufs von Daten aus Xenia und der Speicherung
diese Daten in Pillar zu speichern.

    func Pull(x *Xenia, data []Data) (int, error) {
        for i := Bereich Daten {
            if err := x.Pull(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

    func Store(p *Pillar, data []Data) (int, error) {
        for i := Bereich Daten {
            if err := p.Store(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

Die nächste Ebene des Codes wird durch die beiden Funktionen Pull und Store dargestellt. Sie
bauen auf der primitiven Codeschicht auf, indem sie eine Sammlung von Datenwerten akzeptieren, die
in die jeweiligen Systeme zu ziehen oder zu speichern. Diese Funktionen konzentrieren sich auf die konkreten Typen
von Xenia und Pillar, da dies die Systeme sind, mit denen das Programm zu diesem Zeitpunkt arbeiten
diesem Zeitpunkt arbeiten muss.

    func Copy(sys *System, batch int) error {
        Daten := make([]Daten, Batch)

        for {
            i, err := Pull(&sys.Xenia, Daten)
            wenn i > 0 {
                if _, err := Store(&sys.Pillar, data[:i]); err != nil {
                    return err
                }
            }

            if err != nil {
                return err
            }
        }
    }

Die Kopierfunktion baut auf den Pull- und Store-Funktionen auf und verschiebt alle
Daten, die für jeden Lauf anstehen. Der erste Parameter von Copy ist der Typ
ein Typ namens System.

    Typ System struct {
        Xenia
        Säule
    }

Die ursprüngliche Idee des Typs System besteht darin, ein System zu erstellen, das weiß, wie man zieht
und speichern kann. In diesem Fall wird die Fähigkeit zu Pull und Store aus Xenia und Pillar zusammengesetzt.

    func main() {
        sys := System{
            Xenia: Xenia{
                Host:    "localhost:8000",
                Timeout: time.Second,
            },
            Säule: Pillar{
                Host:    "localhost:9000",
                Timeout: time.Second,
            },
        }

        if err := Copy(&sys, 3); err != io.EOF {
            fmt.Println(err)
        }
    }

Schließlich kann die Hauptfunktion geschrieben werden, um eine Xenia und einen Pillar innerhalb
die Zusammensetzung eines Systems. Dann kann das System an die Funktion Copy übergeben werden
übergeben und der Datenfluss zwischen den beiden Systemen kann beginnen.

Mit all diesem Code haben Sie nun meinen ersten Entwurf einer konkreten Lösung für ein konkretes
Problem.

** Entkopplung mit Schnittstellen

Der nächste Schritt besteht darin, zu verstehen, was sich im Programm ändern könnte. In diesem Fall sind die
sind es die Systeme selbst, die sich ändern können. Heute sind es Xenia und Pillar, morgen könnten es
Alice und Bob sein. Mit diesem Wissen wollen Sie die bestehende konkrete Lösung von dieser Veränderung abkoppeln.
Lösung von dieser Veränderung abkoppeln. Zu diesem Zweck müssen die konkreten Funktionen in
polymorphe Funktionen werden.

    func Pull(p Puller, data []Data) (int, error) {
        for i := Bereich Daten {
            if err := p.Pull(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

    func Store(s Storer, data []Data) (int, error) {
        for i := Bereich Daten {
            if err := s.Store(&data[i]); err != nil {
                return i, err
            }
        }

        return len(data), nil
    }

Derzeit akzeptiert die Pull-Funktion einen Xenia-Wert und die Store-Funktion einen
einen Pillar-Wert. Letztendlich waren nicht Xenia und Pillar wichtig, sondern ein
was wichtig ist, ist ein konkreter Wert, der weiß, wie man zieht und speichert. Sie können diese
konkreten Funktionen polymorph werden, indem man nach Daten fragt, die darauf basieren, was sie tun können
und nicht danach, was sie sind.

    type Puller interface {
        Pull(d *Data) Fehler
    }

    Typ Storer Schnittstelle {
        Store(d *Data) error
    }

Diese beiden Schnittstellen beschreiben, was konkrete Daten tun müssen, und es sind diese Typen, die
werden in der Deklaration der Pull- und Store-Funktionen ersetzt. Nun sind diese Funktionen
sind polymorph. Wenn Alice und Bob als Puller und Storer deklariert und implementiert werden
Storer deklariert und implementiert werden, können sie an die Funktionen übergeben werden.

Sie sind noch nicht fertig. Die Kopierfunktion muss ebenfalls polymorph sein.

    func Copy(ps PullStorer, batch int) error {
        Daten := make([]Daten, Batch)

        für {
            i, err := Pull(ps, Daten)
            wenn i > 0 {
                if _, err := Store(ps, data[:i]); err != nil {
                    return err
                }
            }

            if err != nil {
                return err
            }
        }
    }

Die Kopierfunktion fragt nicht mehr nach einem Systemwert, sondern nach einem konkreten Wert
der sowohl Pull als auch Store beherrscht.

    Typ PullStorer Schnittstelle {
        Puller
        Storer
    }

Die PullStorer-Schnittstelle wird durch die Verwendung von Composition deklariert. Sie ist zusammengesetzt
aus den Schnittstellen Puller und Storer. Arbeiten Sie auf die Komposition größerer Schnittstellen
aus kleineren Schnittstellen.

Beachten Sie, dass die Variable PullStorer jetzt an die Funktionen Pull und Store übergeben wird
Funktionen übergeben wird. Wie ist das möglich, wenn die Typinformationen unterschiedlich sind?

    // func Pull(p Puller, data []Data) (int, error) {
    i, err := Pull(ps, daten)

    // func Store(s Storer, data []Data) (int, error) {
    if _, err := Store(ps, daten[:i]); err != nil {

Sie müssen immer daran denken, dass Sie niemals einen Schnittstellenwert in meinem Programm übergeben
da sie nicht existieren und wertlos sind. Sie können nur konkrete Daten übergeben. Also werden die
konkreten Daten, die in der Variablen ps der Schnittstelle gespeichert sind, werden an
an Pull und Store übergeben. Ist es nicht so, dass der konkrete Wert, der in ps gespeichert ist, wissen muss
wissen, wie man Pull und Store benutzt?

.image /tour/eng/static/img/comp1.png

Da ein System aus Xenia und Pillar zusammengesetzt ist, implementiert System die PullStorer
Schnittstelle. Mit diesen Änderungen können Sie nun neue konkrete Typen erstellen, die das
das PullStorer-Interface implementieren.

    Typ System1 struct {
        Xenia
        Säule
    }

    Typ System2 struct {
        Alice
        Bob
    }

    Typ System3 struct {
        Xenia
        Bob
    }

    Typ System4 struct {
        Alice
        Säule
    }

Wenn man genauer darüber nachdenkt, ist die Deklaration verschiedener Systemtypen für alle möglichen
Kombinationen zu deklarieren, ist nicht realistisch. Das wird funktionieren, aber der Wartungsalptraum erfordert
eine bessere Lösung.

** Zusammensetzung der Schnittstelle

Was wäre, wenn Sie meinen konkreten Systemtyp aus zwei Schnittstellentypen zusammensetzen würden?

    Typ System struct {
        Abzieher
        Storer
    }

Dies ist eine interessante Lösung. Dies würde es der Anwendung ermöglichen, den
konkreten Puller oder Storer beim Start der Anwendung in das System zu injizieren.

    func main() {
        sys := System{
            Abzieher: &Xenia{
                Host:    "localhost:8000",
                Timeout: time.Second,
            },
            Storer: &Pillar{
                Host:    "localhost:9000",
                Timeout: time.Second,
            },
        }

        if err := Copy(&sys, 3); err != io.EOF {
            fmt.Println(err)
        }
    }

Dieser eine Systemtyp implementiert die PullStorer-Schnittstelle für alle möglichen
Kombinationen von konkreten Typen.

.image /tour/eng/static/img/comp2.png

Mit dieser Änderung wird die Anwendung vollständig von Änderungen an einem neuen System entkoppelt
das mit der Zeit online gehen könnte.

** Präzisionsprüfung

Die nächste Frage, die sich stellt, ist, ob die polymorphen Funktionen so präzise sind, wie sie
wie sie sonst sein könnten? Dies ist ein Teil des Entwicklungsprozesses, der nicht übersprungen werden kann.
Die Antwort lautet nein. Es können zwei Änderungen vorgenommen werden.

    func Copy(sys *System, batch int) error {

Die Funktion Copy muss nicht mehr polymorph sein, da es nur noch einen
einzigen System-Typ gibt. Der Typ der PullStorer-Schnittstelle kann aus dem Programm entfernt werden.
Denken Sie daran, dass Sie die Polymorphie innerhalb des Typs verschoben haben, als Sie die Komposition mit den
Schnittstellentypen verwendet haben.

    func Copy(p Puller, s Storer, batch int) error {

Dies ist eine weitere Änderung, die an der Kopierfunktion vorgenommen werden kann. Diese Änderung macht die
Funktion wieder präziser und polymorpher. Jetzt fragt die Funktion genau nach
was sie braucht, je nachdem, was die konkreten Daten leisten können.

.image /tour/eng/static/img/comp3.png

Mit dieser Änderung kann auch der Typ System struct aus dem Programm entfernt werden.

    func main() {
        x := Xenia{
            Host:    "localhost:8000",
            Timeout: time.Second,
        }

        p := Säule{
            Host:    "localhost:9000",
            Timeout: time.Second,
        }

        if err := Copy(&x, &p, 3); err != io.EOF {
            fmt.Println(err)
        }
    }

Durch das Entfernen der Typen PullStorer und System wird das Programm vereinfacht. Die Haupt
Funktion kann sich auf die Konstruktion der konkreten Puller- und Storer-Werte konzentrieren, die
für die bewegten Daten. Das Typsystem und die APIs sind präziser.
Diese Idee der Präzision stammt von Edsger W. Dijkstra

"Der Zweck der Abstraktion besteht nicht darin, vage zu sein, sondern eine neue semantische Ebene zu schaffen, auf der man absolut präzise sein kann". - Edsger W. Dijkstra

** Anmerkungen

- Dies ist viel mehr als nur die Mechanik der Typeneinbettung.
- Deklarieren Sie Typen und implementieren Sie Arbeitsabläufe unter Berücksichtigung der Komposition.
- Verstehen Sie zuerst das Problem, das Sie zu lösen versuchen. Das bedeutet, die Daten zu verstehen.
- Das Ziel ist es, kaskadenartige Änderungen in Ihrer Software zu reduzieren und zu minimieren.
- Schnittstellen bieten die höchste Form der Komposition.
- Gruppieren Sie Typen nicht nach einer gemeinsamen DNA, sondern nach einem gemeinsamen Verhalten.
- Alle können zusammenarbeiten, wenn wir uns darauf konzentrieren, was wir tun und nicht, was wir sind.

** Zitate

"Eine gute API ist nicht nur einfach zu benutzen, sondern auch schwer zu missbrauchen." - JBD

"Man kann immer einbetten, aber man kann keine großen Schnittstellen zerlegen, wenn sie einmal da sind. Halten Sie die Schnittstellen klein." - JBD

"Entwerfen Sie nicht mit Schnittstellen, entdecken Sie sie". - Rob Pike

"Eine Verdoppelung ist viel billiger als eine falsche Abstraktion. - Sandi Metz

** Gestaltungsrichtlinien

Informieren Sie sich über die [[https://github.com/ardanlabs/gotraining/blob/master/topics/go/#interface-and-composition-design]]-Gestaltungsrichtlinien]] für die Gestaltung.

** Extra Lesen

- [[https://programmingisterrible.com/post/176657481103/repeat-yourself-do-more-than-one-thing-and][Wiederhole dich, mach mehr als eine Sache und schreibe alles neu]] - tef
- [[https://golang.org/doc/effective_go.html#embedding][Einbettung]]
- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Methoden, Schnittstellen und Einbettung]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2015/09/composition-with-go.html][Komposition in Go]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2016/10/reducing-type-hierarchies.html][Reduktion von Typenhierarchien]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2016/10/avoid-interface-pollution.html][Vermeiden von Schnittstellenverschmutzung]] - William Kennedy

* Übungen

Verwenden Sie die Vorlage als Ausgangspunkt, um die Aufgaben zu lösen. Eine mögliche Lösung ist angegeben.

** Übung 1

Deklarieren Sie mit Hilfe der Vorlage eine Reihe konkreter Typen, die die Menge der vordefinierten
Schnittstellentypen implementieren. Erstellen Sie dann Werte dieser Typen und verwenden Sie sie zur Erfüllung einer Reihe von
vordefinierten Aufgaben.

.play composition/decoupling/exercise1.go
.play composition/decoupling/answer1.go
