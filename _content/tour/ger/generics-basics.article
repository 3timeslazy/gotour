Grundlagen
Lernen Sie, wie man eine grundlegende generische Druckfunktion schreibt.

* Generika - Grundlagen

Lernen Sie, wie man eine einfache generische Druckfunktion schreibt.

** Video

Schauen Sie sich den Vortrag über Generics an, der Sie durch alle
Beispiele in diesem Abschnitt der Tour.

.html generics-video.html

** Code-Überprüfung

- *Beispiel* *1*: Konkrete Umsetzung von print
- *Beispiel* *2*: Type Assertion-Implementierung von print
- *Beispiel* *3*: Reflection-Implementierung von print
- *Beispiel* *4*: Generische Implementierung von print

.play generics/basics/example1.go
.play generics/basics/example2.go
.play generics/basics/example3.go
.play generics/basics/example4.go

** Erläutert

Wenn Sie eine einzelne Druckfunktion schreiben wollen, die ein Slice eines beliebigen Typs ausgeben kann
ausgeben kann, ohne Reflexion zu verwenden, können Sie die neue generische Syntax verwenden.

    func print[T any](slice []T) {
        fmt.Print("Generisch: ")
        
        for _, v := range slice {
            fmt.Print(v, " ")
        }

        fmt.Print("\n")
    }

Dies ist eine Implementierung einer einzelnen Druckfunktion, die ein Slice eines beliebigen Typs ausgeben kann.
Typs unter Verwendung der neuen generischen Syntax ausgibt. Das Schöne an dieser Syntax ist, dass der
Code innerhalb der Funktion die Syntax und die eingebauten Funktionen verwenden kann, die auch mit
einem konkreten Typ. Dies ist nicht der Fall, wenn Sie die leere Schnittstelle verwenden, um generischen
Code schreiben.

Es muss eine Möglichkeit geben, dem Compiler mitzuteilen, dass Sie den Typ T nicht explizit deklarieren werden, aber es muss
muss vom Compiler zur Kompilierzeit bestimmt werden. Die neue Syntax verwendet dazu eckige
Klammern für diesen Zweck. Die Klammern definieren eine Liste von generischen Typbezeichnern, die für
Typen darstellen, die für die Funktion spezifisch sind und zur Kompilierzeit bestimmt werden müssen. Auf diese Weise teilen Sie
dem Compiler mit, dass Typen mit diesen Namen nicht deklariert werden, bevor das Programm
kompiliert wird. Diese Typen müssen zur Kompilierzeit ermittelt werden.

Hinweis: Innerhalb der eckigen Klammern können mehrere Typbezeichner definiert werden, obwohl das
dieses Beispiel nur einen verwendet. Bsp. [T, S, R beliebig]

Sie können diese Typbezeichner beliebig benennen, um die Lesbarkeit des Codes zu verbessern.
Codes. In diesem Fall verwendet der Code den Großbuchstaben T, um zu beschreiben, dass ein Slice des Typs
T (zur Kompilierzeit zu bestimmen) übergeben wird. Es ist ein Idiom, einen einzelnen
Großbuchstaben zu verwenden, wenn es um Sammlungen geht, und es ist auch eine Konvention, die
die auf ältere Programmiersprachen wie C++ und Java zurückgeht.

Auch innerhalb der Klammern wird das Wort any verwendet. Dies stellt eine
Einschränkung, welcher Typ T sein kann. Der Compiler verlangt, dass alle generischen Typen eine
eine gut definierte Einschränkung haben. Die any-Beschränkung wird vom Compiler vordeklariert und
besagt, dass es keine Beschränkungen dafür gibt, was der Typ T sein kann.

    Zahlen := []int{1, 2, 3}
    print[int](numbers)

    strings := []string{"A", "B", "C"}
    print[string](strings)
    
    floats := []float64{1.7, 2.2, 3.14}
    print[float64](floats)

So können Sie die generische Druckfunktion aufrufen, wenn die Typinformationen
für T explizit an der Aufrufstelle bereitgestellt wird. Die Syntax emuliert die Idee, dass die
Funktionsdeklaration func name[T any](slice []T) zwei Sätze von Parametern definiert.
Der erste Satz ist der Typ, der auf die entsprechenden Typbezeichner abgebildet wird, und der
zweite sind die Daten, die auf die entsprechenden Eingabevariablen abgebildet werden.

Glücklicherweise kann der Compiler den Typ ableiten und macht die explizite Übergabe von
Typinformationen an der Aufrufstelle zu übergeben.

    Zahlen := []int{1, 2, 3}
    print(zahlen)
    
    strings := []string{"A", "B", "C"}
    print(zeichenketten)
    
    floats := []float64{1.7, 2.2, 3.14}
    print(floats)

Dieser Code zeigt, wie Sie die generischen Druckfunktionen aufrufen können, ohne dass Sie die
die Typinformationen explizit zu übergeben. An der Stelle des Funktionsaufrufs ist der Compiler in der Lage
den für T zu verwendenden Typ zu erkennen und eine konkrete Version der Funktion zu konstruieren, die
Slices dieses Typs zu unterstützen. Der Compiler ist in der Lage, den Typ anhand der
Informationen, die ihm an der Aufrufstelle vorliegen, aus den übergebenen Daten abzuleiten.

* Übungen

Verwenden Sie die Vorlage als Ausgangspunkt, um die Aufgaben zu lösen. Eine mögliche Lösung ist angegeben.

** Übung 1

Implementieren Sie eine generische Funktion namens marshal, die einen beliebigen Wert annehmen und
diesen Wert in JSON umwandelt und das JSON sowie einen Fehler zurückgibt. Deklarieren Sie
einen struct-Typ namens User mit zwei Feldern, Name und Alter. Konstruieren Sie dann einen
Wert des Typs User und übergeben Sie den Wert an die generische Funktion marshal.

.play generics/basics/exercise1.go 
.play generics/basics/answer1.go
