Zugrundeliegende Typen
Ihr könnt einen generischen Typ unter Verwendung eines zugrundeliegenden Typs deklarieren.

* Generika - Zugrunde liegende Typen

Ihr könnt einen generischen Typ unter Verwendung eines zugrunde liegenden Typs deklarieren.

** Video

Schaut sich den Vortrag über Generics an, der euch durch alle
Beispiele in diesem Abschnitt der Tour führt.

.html generics-video.html

** Code-Überprüfung

- *Beispiel* *1*: Konkreter Vektortyp
- *Beispiel* *2*: Interface-Vektortyp
- *Beispiel* *3*: Generischer Vektortyp

.play generics/underlying-types/example1.go
.play generics/underlying-types/example2.go
.play generics/underlying-types/example3.go

** Erläutert

Was wäre, wenn ich meinen eigenen generischen Typ unter Verwendung eines zugrunde liegenden Typs deklarieren wollte?

    Typ Vektor[T beliebig] []T

    func (v vector[T]) last() (T, error) {
        var null T
        
        if len(v) == 0 {
            return zero, errors.New("leer")
        }
        
        return v[len(v)-1], nil
    }

Dieses Beispiel zeigt einen generischen Vektortyp, der die Konstruktion eines Vektors
auf einen einzigen Datentyp beschränkt. Die Verwendung von eckigen Klammern erklärt, dass der Typ T ein generischer Typ ist
Typ ist, der zur Kompilierzeit bestimmt wird. Die Verwendung der Einschränkung "any" beschreibt
dass es keine Beschränkung gibt, was für ein Typ T werden kann.

Die letzte Methode wird mit einem Werteempfänger vom Typ vector[T] deklariert, um einen
Wert vom Typ vector mit einem zugrundeliegenden Slice vom Typ T darzustellen. Die Methode gibt einen
Wert desselben Typs T zurück.

    func main() {
        fmt.Print("vector[int] : ")

        vGenInt := vector[int]{10, -1}

        i, err := vGenInt.last()
        if err != nil {
            fmt.Print("ERROR:", err)
            return
        }

        wenn i < 0 {
            fmt.Print("negative ganze Zahl: ")
        }

        fmt.Printf("Wert: %d\n", i)

        // -------------------------------------------------------------------------

        fmt.Print("vector[string] : ")

        vGenStr := vector[string]{"A", "B", string([]byte{0xff})}

        s, err := vGenStr.last()
        if err != nil {
            fmt.Print("ERROR:", err)
            return
        }

        if !utf8.ValidString(s) {
            fmt.Print("nicht gültiger String: ")
        }

        fmt.Printf("Wert: %q\n", s)
    }

Ausgabe:

    vector[int] : negative Ganzzahl: Wert: -1
    vector[string] : nicht gültiger String: Wert: "\xff"

So konstruiere ich einen Wert vom Typ vector mit einem zugrunde liegenden Typ int, wenn ich
bei der Konstruktion Werte im Vektor setzt. Ein wichtiger Aspekt dieses Codes sind die
Konstruktionsaufrufe.

    // Nullwert-Konstruktion
    var vGenInt vector[int]
    var vGenStr vector[string]
    
    // Nicht-Nullwert-Konstruktion
    vGenInt := Vektor{10, -1}
    vGenStr := vector{"A", "B", string([]byte{0xff})}

Wenn es darum geht, diese generischen Typen auf ihren Nullwert zu konstruieren, ist es
ist es für den Compiler nicht möglich, den Typ zu ermitteln. In den Fällen jedoch, in denen es eine
Initialisierung während der Konstruktion, kann der Compiler den Typ ableiten.

Es gibt einen Aspekt der Spezifikation, der sich auf die Konstruktion eines generischen Typs in
seinem Nullwert-Zustand.

    Typ Vektor[T beliebig] []T
    
    func (v vector[T]) last() (T, error) {
        var null T
        
        if len(v) == 0 {
            return zero, errors.New("leer")
        }
        
        return v[len(v)-1], nil
    }

Ihr müsst euch auf die Methodendeklaration für die letzte Methode konzentrieren und darauf, wie die Methode
einen Wert des generischen Typs T zurückgibt. Bei der ersten Rückgabe ist eine Situation gegeben, in der ihr
den Nullwert für den Typ T zurückgeben. Die aktuelle Implementierung bietet zwei Lösungen für die Erstellung von
diesen Code zu schreiben. Die erste Lösung Seht euch bereits. Eine Variable mit dem Namen Null wird konstruiert, um
ihren Nullwert-Zustand des Typs T und dann wird diese Variable für die Rückgabe verwendet.

Die andere Möglichkeit ist die Verwendung der eingebauten Funktion new und die Dereferenzierung des zurückgegebenen
Zeiger innerhalb der Return-Anweisung zu dereferenzieren.

    Typ Vektor[T beliebig] []T
    
    func (v vector[T]) last() (T, error) {
        if len(v) == 0 {
            return *new(T), errors.New("leer")
        }
        
        return v[len(v)-1], nil
    }

Diese Version der letzten Methode verwendet die eingebaute Funktion new für die Nullwert
Konstruktion und Dereferenzierung des zurückgegebenen Zeigers, um den Rückgabetyp T zu erfüllen.

Hinweis: Man könnte meinen, warum nicht T{} verwenden, um eine Nullwertkonstruktion durchzuführen? Das
Problem ist, dass diese Syntax nicht mit allen Typen funktioniert, wie z.B. den skalaren Typen (int,
string, bool). Sie ist also keine Option.

* Übungen

Verwendet die Vorlage als Ausgangspunkt, um die Aufgaben zu lösen. Eine mögliche Lösung ist angegeben.

** Übung 1

Deklariert einen generischen Typ namens keymap, der einen zugrundeliegenden Typ von map verwendet
mit einem Schlüssel vom Typ string und einem Wert vom Typ T verwendet. Deklariert eine Methode
namens set, die einen Schlüssel vom Typ string und einen Wert vom Typ T akzeptiert. Deklariert
eine Methode namens get, die einen Schlüssel vom Typ string akzeptiert und einen Wert vom
Typ T und true oder false zurückgibt, wenn der Schlüssel gefunden wird. Schreibt dann eine Hauptfunktion
die die Methoden verwendet.

.play generics/underlying-types/exercise1.go 
.play generics/underlying-types/answer1.go