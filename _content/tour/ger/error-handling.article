Fehlerbehandlung
Die Fehlerbehandlung ist entscheidend dafür, dass Ihre Programme zuverlässig, vertrauenswürdig und respektvoll gegenüber denjenigen sind, die auf sie angewiesen sind.

* Entwurf der Fehlerbehandlung

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Das Video ansehen]]
- Benötigen Sie finanzielle Unterstützung, nutzen Sie unser [[https://www.ardanlabs.com/scholarship/][Stipendienformular]]

Integrität ist wichtig, und sie ist ein wichtiger Teil des technischen Prozesses. Das Herzstück der
Integrität ist die Fehlerbehandlung. Bei Go ist die Fehlerbehandlung keine Ausnahme
die später oder an anderer Stelle im Code behandelt werden muss. Sie ist ein Teil des Hauptpfades und
muss ein Hauptaugenmerk sein.

Die Entwickler haben die Verantwortung, genügend Kontext über jeden Fehler zu liefern, damit ein
Benutzer eine fundierte Entscheidung treffen kann, wie er weiter vorgehen soll. Bei der Behandlung eines Fehlers geht es
geht es um drei Dinge: den Fehler protokollieren, den Fehler nicht weiter verbreiten und
Feststellung, ob die Goroutine/das Programm beendet werden muss.

In Go sind Fehler einfach nur Werte, die alles sein können, was Sie brauchen. Sie
können jeden Zustand oder jedes Verhalten beibehalten.

** Code-Überprüfung

- *Beispiel* *1:* Standard-Fehlerwerte
- *Beispiel* *2:* Fehlervariablen
- *Beispiel* *3:* Type As Context
- *Beispiel* *4:* Verhalten als Kontext
- *Beispiel* *5:* Finde den Fehler
- *Beispiel* *6:* Wrapping von Fehlern mit stdlib

.play error-handling/example1.go
.play error-handling/example2.go
.play error-handling/example3.go
.play error-handling/example4.go
.play error-handling/example5.go
.play error-handling/example6.go

** Grundlagen der Fehlerbehandlung

Die Fehlerschnittstelle ist in die Sprache integriert.

    // http://golang.org/pkg/builtin/#error
    type error interface {
        String Error()
    }

Aus diesem Grund scheint es sich um einen nicht exportierten Bezeichner zu handeln. Jeder konkrete Wert, der
diese Schnittstelle implementiert, kann als Fehlerwert verwendet werden.

Ein wichtiger Aspekt von Go ist, dass die Fehlerbehandlung in einem entkoppelten Zustand erfolgt
über diese Schnittstelle erfolgt. Ein Hauptgrund dafür ist, dass die Fehlerbehandlung ein Aspekt meiner Anwendung ist
Aspekt meiner Anwendung ist, der anfälliger für Änderungen und Verbesserungen ist.
Diese Schnittstelle ist der Typ, den Go-Anwendungen als Rückgabetyp für die Fehlerbehandlung verwenden müssen.
Behandlung verwenden.

    // http://golang.org/src/pkg/errors/errors.go
    type errorString struct {
        s string
    }

    // http://golang.org/src/pkg/errors/errors.go
    func (e *errorString) Error() string {
        return e.s
    }

Dies ist der am häufigsten verwendete Fehlerwert in Go-Programmen. Er ist deklariert im
errors-Paket der Standardbibliothek deklariert. Beachten Sie, dass der Typ nicht exportiert ist und
er hat ein nicht exportiertes Feld, das ein String ist. Sie können auch sehen, wie die Zeigersemantik
verwendet wird, um die Fehlerschnittstelle zu implementieren. Das bedeutet, dass nur Adressen auf Werte
dieses Typs können gemeinsam genutzt und innerhalb der Schnittstelle gespeichert werden. Die Methode gab gerade
den Fehlerstring zurück.

Es ist wichtig, daran zu denken, dass die Implementierung der Error-Methode dem Zweck dient
Zweck der Implementierung der Schnittstelle und der Protokollierung. Wenn ein Benutzer die von dieser Methode
die von dieser Methode zurückgegebene Zeichenkette analysieren muss, haben Sie es versäumt, dem Benutzer die
Kontext zu liefern, um eine fundierte Entscheidung treffen zu können.

    // http://golang.org/src/pkg/errors/errors.go
    func New(text string) error {
        return &errorString{text}
    }

Die Funktion New zeigt, wie ein Fehler mit dem konkreten Typ errorString konstruiert wird.
Beachten Sie, wie die Funktion den Fehler unter Verwendung der Fehlerschnittstelle zurückgibt. Beachten Sie auch
wie die Zeigersemantik verwendet wird.

    func main() {
        if err := webCall(); err != nil {
            fmt.Println(err)
            return
        }
        fmt.Println("Das Leben ist gut")
    }

    func webCall() error {
        return New("schlechte Anfrage")
    }

Bei Fehlern ist der Kontext alles. Jeder Fehler muss genügend Kontext bieten, damit
den Aufrufer in die Lage versetzt, eine fundierte Entscheidung über den Zustand der Goroutine/Anwendung zu treffen.
In diesem Beispiel gibt die Funktion webCall einen Fehler mit der Meldung Bad Request zurück.
In der Hauptfunktion wird webCall aufgerufen und dann geprüft, ob
ob bei diesem Aufruf ein Fehler aufgetreten ist.

    if err := webCall(); err != nil {
        fmt.Println(err)
        return
    }

Der Schlüssel zur Prüfung ist err != nil. Diese Bedingung besagt, ob ein konkreter Wert
konkreter Wert innerhalb des err-Schnittstellenwertes gespeichert ist. Wenn der Schnittstellenwert
einen konkreten Wert speichert, liegt ein Fehler vor. In diesem Fall ist der Kontext buchstäblich
nur die Tatsache, dass ein konkreter Wert existiert, es ist nicht wichtig, was der konkrete
Wert ist.

Was ist, wenn es wichtig ist zu wissen, welcher Fehlerwert in der Schnittstellenvariable err
Variable steht? Dann sind Fehlervariablen eine gute Option.

    var (
        ErrBadRequest = errors.New("Schlechte Anfrage")
        ErrPageMoved = errors.New("Seite verschoben")
    )

Fehlervariablen bieten einen Mechanismus zur Identifizierung des spezifischen Fehlers, der zurückgegeben wird.
Sie haben das Idiom mit dem Präfix Err zu beginnen und basieren auf dem konkreten Typ
errorString aus dem Paket errors.

    func webCall(b bool) error {
        if b {
            return ErrBadRequest
        }
        return ErrPageMoved
    }

In dieser neuen Version von webCall gibt die Funktion die eine oder die andere Fehlervariable zurück.
Dadurch kann der Aufrufer feststellen, welcher Fehler aufgetreten ist.

    func main() {
        if err := webCall(true); err != nil {
            switch err {
            case ErrBadRequest:
                fmt.Println("Bad Request Occurred")
                return

            case ErrPageMoved:
                fmt.Println("Die Seite wurde verschoben")
                return

            Standard:
                fmt.Println(err)
                return
            }
        }

        fmt.Println("Das Leben ist gut")
    }

In der Anwendung kann nach dem Aufruf von webCall geprüft werden, ob
ob ein konkreter Wert in der Schnittstellenvariablen err gespeichert ist. Falls
ein konkreter Wert in der Schnittstellenvariablen err gespeichert ist, wird mit Hilfe einer switch-Anweisung ermittelt, um welchen Fehler es sich handelt, indem err
mit den verschiedenen Fehlervariablen verglichen wird.

In diesem Fall richtet sich der Kontext des Fehlers danach, welche Fehlervariable zurückgegeben wurde.
Was ist, wenn eine Fehlervariable als Kontext nicht ausreicht? Was ist, wenn ein spezieller Zustand
geprüft werden muss, wie bei Netzwerkfehlern? In diesen Fällen ist ein eigener konkreter Fehlertyp
Typ die Antwort.

    type UnmarshalTypeError struct {
        Wert string
        Typ reflect.Type
    }

    func (e *UnmarshalTypeError) Error() string {
        return "json: cannot unmarshal " + e.Value +
            " in Go-Wert vom Typ " + e.Type.String()
    }

Dies ist ein benutzerdefinierter konkreter Fehlertyp, der im json-Paket implementiert ist. Beachten Sie, dass der
Name hat ein Suffix von Error in der Benennung des Typs. Beachten Sie auch die Verwendung von
Zeigersemantik für die Implementierung der Fehlerschnittstelle. Auch hier ist die
Implementierung ist für die Protokollierung und sollte Informationen über alle Felder anzeigen
erfasst werden.

    type InvalidUnmarshalError struct {
        Typ reflect.Type
    }

    func (e *InvalidUnmarshalError) Error() string {
        if e.Type == nil {
            return "json: Unmarshal(nil)"
        }
        if e.Type.Kind() != reflect.Ptr {
            return "json: Unmarshal(Nicht-Zeiger " + e.Type.String() + ")"
        }
        return "json: Unmarshal(nil " + e.Type.String() + ")"
    }

Dies ist ein zweiter benutzerdefinierter konkreter Fehlertyp aus dem json-Paket. Die Implementierung
der Error-Methode ist etwas komplexer, aber auch hier nur für die Protokollierung und
Zeiger-Semantik zu verwenden.

    func Unmarshal(data []byte, v interface{}) error {
        rv := reflect.ValueOf(v)
        if rv.Kind() != reflect.Ptr || rv.IsNil() {
            return &InvalidUnmarshalError{reflect.TypeOf(v)}
        }
        return &UnmarshalTypeError{"string", reflect.TypeOf(v)}
    }

Hier ist ein Teil der Unmarshal-Funktion. Beachten Sie, wie sie die konkreten
Fehlerwerte in der Rückgabe konstruiert und sie über die Fehlerschnittstelle an den Aufrufer zurückgibt.
Es wird eine semantische Zeigerkonstruktion verwendet, da die Zeigersemantik in der
der Deklaration der Methode Error verwendet wurde.

Der Kontext des Fehlers bezieht sich hier eher auf die Art des Fehlers, der in der
Fehlerschnittstelle gespeichert ist. Es muss eine Möglichkeit geben, dies zu bestimmen.

    func main() {
        var u Benutzer
        err := Unmarshal([]byte(`{"name": "bill"}`), u)
        if err != nil {
            switch e := err.(type) {
            case *UnmarshalTypeError:
                fmt.Printf("UnmarshalTypeError: Value[%s] Type[%v]\n",
                    e.Value, e.Type)
            case *InvalidUnmarshalError:
                fmt.Printf("InvalidUnmarshalError: Type[%v]\n", e.Type)
            Standard:
                fmt.Println(err)
            }
            return
        }
        fmt.Println("Name:", u.Name)
    }

Mit einer generischen Typ-Assertion im Rahmen der switch-Anweisung können Sie
Code schreiben, um zu testen, welcher Typ von Wert in dem Wert der err-Schnittstelle gespeichert ist.
Der Typ ist hier der Kontext, und jetzt können Sie testen und Maßnahmen ergreifen, die Zugriff auf alle
alle Zustände des Fehlers.

Das bringt allerdings ein Problem mit sich. Ich bin nicht mehr vom konkreten Fehlerwert entkoppelt
Wert. Das heißt, wenn der konkrete Fehlerwert geändert wird, kann mein Code zusammenbrechen. Der
schöne Teil der Verwendung einer Schnittstelle zur Fehlerbehandlung ist die Entkopplung von
Änderungen entkoppelt ist.

Wenn der konkrete Fehlerwert eine Methode hat, dann können Sie eine Schnittstelle für die
die Typprüfung verwenden. Das Netzpaket hat zum Beispiel viele konkrete Fehlertypen, die
verschiedene Methoden implementieren. Eine gängige Methode heißt Temporary. Diese Methode
ermöglicht es dem Benutzer zu testen, ob der Netzwerkfehler kritisch ist oder nur etwas
der sich von selbst beheben kann.

    type temporary interface {
        Temporär() bool
    }

    func (c *client) BehaviorAsContext() {
        for {
            Zeile, err := c.reader.ReadString('\n')
            if err != nil {
                switch e := err.(type) {
                case temporär:
                    if !e.Temporär() {
                        log.Println("Vorübergehend: Kunde verlässt Chat")
                        return
                    }
                default:
                    if err == io.EOF {
                        log.Println("EOF: Klient verlässt Chat")
                        return
                    }
                    log.Println("read-routine", err)
                }
            }
            fmt.Println(line)
        }
    }

In diesem Code könnte der Aufruf von ReadString mit einem Fehler aus dem Netzpaket fehlschlagen.
In diesem Fall wird eine Schnittstelle deklariert, die das allgemeine Verhalten darstellt, das ein bestimmter
konkreter Fehlerwert implementieren könnte. Mit einer generischen Typprüfung wird dann getestet
ob dieses Verhalten existiert und man kann es aufrufen. Das Beste daran: Sie bleiben in einem
entkoppelten Zustand mit meiner Fehlerbehandlung.

** Verwenden Sie immer die Fehlerschnittstelle

Ein Fehler, den Go-Entwickler machen können, ist, dass sie den konkreten Fehlertyp und
und nicht die Fehlerschnittstelle für den Rückgabetyp zur Fehlerbehandlung verwenden. Wenn Sie
dies tun, können schlimme Dinge passieren.

    type customError struct{}

    func (c *customError) Error() string {
        return "Finde den Fehler."
    }

    func fail() ([]byte, *customError) {
        return nil, nil
    }

    func main() {
        var err Fehler
        if _, err = fail(); err != nil {
            log.Fatal("Warum ist das fehlgeschlagen?")
        }
        log.Println("Kein Fehler")
    }

Ausgabe:
    
    Warum ist das gescheitert?

Warum glaubt dieser Code, dass ein Fehler vorliegt, obwohl die Fail-Funktion den Wert Null für
den Fehler zurückgibt? Das liegt daran, dass die Fail-Funktion den konkreten Fehlertyp verwendet und nicht
die Fehlerschnittstelle verwendet. In diesem Fall ist ein Null-Zeiger des Typs customError
in der err-Variable gespeichert. Das ist nicht dasselbe wie ein Nullwert der Schnittstelle vom Typ error.

** Fehlerbehandlung

Der Umgang mit Fehlern ist eher eine technische Angelegenheit auf Makroebene. In meiner Welt bedeutet Fehler
bedeutet Fehlerbehandlung, dass der Fehler bei der fehlerbehandelnden Funktion aufhört, der Fehler
der Fehler mit vollständigem Kontext protokolliert und der Fehler auf seinen Schweregrad geprüft wird. Basierend auf der
Schweregrads und der Fähigkeit zur Wiederherstellung wird entschieden, ob der Fehler behoben, fortgesetzt oder beendet werden soll.

Ein Problem ist, dass nicht alle Funktionen mit einem Fehler umgehen können. Ein Grund dafür könnte sein, dass
nicht alle Funktionen protokollieren dürfen. Was passiert, wenn ein Fehler zurück
den Aufrufstapel hochgereicht wird und von der Funktion, die ihn erhält, nicht behandelt werden kann? Ein Fehler muss
in einen Kontext verpackt werden, damit die Funktion, die ihn schließlich behandelt, dies ordnungsgemäß tun kann.

    Paket Haupt

    importieren (
        "errors"
        "fmt"
    )

    type AppError struct {
        Zustand int
    }

    func (ae *AppError) Error() string {
        return fmt.Sprintf("App Error, State: %d", ae.State)
    }

    func IsAppError(err error) bool {
        var ae *AppError
        return errors.As(err, &ae)
    }

    func GetAppError(err error) *AppError {
        var ae *AppError
        if !errors.As(err, &ae) {
            return nil
        }
        return ae
    }

    func main() {
        if err := firstCall(10); err != nil {

            // Prüfen Sie, ob der Fehler ein AppError ist.
            if IsAppError(err) {
                ae := GetAppError(err)
                fmt.Printf("Ist AppError, Zustand: %d\n", ae.State)
            }

            fmt.Print("\n********************************\n\n")

            // Anzeige des Fehlers unter Verwendung der Implementierung der
            // der Fehlerschnittstelle.
            fmt.Printf("%v\n", err)
        }
    }

    func firstCall(i int) error {
        if err := secondCall(i); err != nil {
            return fmt.Errorf("secondCall(%d) : %w", i, err)
        }
        return nil
    }

    func secondCall(i int) error {
        return &AppError{99}
    }

Ausgabe:

    Ist AppError, Status: 99

    ********************************

    secondCall(10) : App Fehler, Zustand: 99

** Anmerkungen

- Verwenden Sie den Standardfehlerwert für statische und einfach formatierte Meldungen.
- Erstellen Sie Fehlervariablen und geben Sie diese zurück, um dem Aufrufer zu helfen, bestimmte Fehler zu identifizieren.
- Erstellen Sie eigene Fehlertypen, wenn der Kontext des Fehlers komplexer ist.
- Fehlerwerte in Go sind nichts Besonderes, sie sind einfach Werte wie alle anderen, und so steht Ihnen die gesamte Sprache zur Verfügung.

** Zitate

"Systeme können nicht in der Annahme entwickelt werden, dass Menschen in der Lage sind, Millionen von Codezeilen fehlerfrei zu schreiben.
Codezeilen zu schreiben, ohne Fehler zu machen, und die Fehlersuche allein ist kein effizienter Weg
um zuverlässige Systeme zu entwickeln." - Al Aho (Erfinder von AWK)

** Extra Lesen

- [[https://go.dev/blog/error-handling-and-go][Fehlerbehandlung und Go]]
- [[https://go.dev/blog/go1.13-errors][Arbeiten mit Fehlern in Go 1.13]]
- [[https://www.ardanlabs.com/blog/2014/10/error-handling-in-go-part-i.html][Fehlerbehandlung in Go, Teil I]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2014/11/error-handling-in-go-part-ii.html][Fehlerbehandlung in Go, Teil II]] - William Kennedy
- [[https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html][Designphilosophie zur Protokollierung]] - William Kennedy
- [[https://clipperhouse.com/bugs-are-a-failure-of-prediction/][Bugs sind ein Versagen der Vorhersage]] - Matt Sherman
- [[https://dave.cheney.net/2014/12/24/inspecting-errors][Inspektion von Fehlern]] - Dave Cheney
- [[https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully][Überprüfen Sie Fehler nicht nur, sondern behandeln Sie sie anständig]] - Dave Cheney
- [[https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package][Stack Traces und das Fehlerpaket]] - Dave Cheney
- [[https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html][Fehlerbehandlung in Upspin]] - Rob Pike
- [[https://rauljordan.com/why-go-error-handling-is-awesome/][Warum Go's Fehlerbehandlung genial ist]] - Raul Jordan
   
* Übungen

Verwenden Sie die Vorlage als Ausgangspunkt, um die Aufgaben zu lösen. Eine mögliche Lösung ist angegeben.

** Übung 1

Erstellen Sie zwei Fehlervariablen, eine mit dem Namen ErrInvalidValue und die andere mit dem Namen
ErrAmountTooLarge. Geben Sie die statische Meldung für jede Variable an. Schreiben Sie dann eine
Funktion namens checkAmount, die einen Wert vom Typ float64 akzeptiert und einen
Fehlerwert zurückgibt. Prüfen Sie den Wert auf Null und geben Sie in diesem Fall den Wert ErrInvalidValue zurück.
Prüfen Sie, ob der Wert größer als $1.000 ist, und geben Sie in diesem Fall den Fehler ErrAmountTooLarge zurück.
Schreiben Sie eine Hauptfunktion, die die Funktion checkAmount aufruft und den zurückgegebenen Fehler
Wert. Geben Sie eine entsprechende Meldung auf dem Bildschirm aus.

.play error-handling/exercise1.go
.play error-handling/answer1.go

** Übung 2

Erstellen Sie einen benutzerdefinierten Fehlertyp namens appError, der drei Felder enthält: err error,
message string und code int. Implementieren Sie die Fehlerschnittstelle mit Ihrer eigenen Nachricht
unter Verwendung dieser drei Felder. Implementieren Sie eine zweite Methode namens temporary, die false zurückgibt
false zurückgibt, wenn der Wert des Feldes code 9 ist. Schreiben Sie eine Funktion namens checkFlag, die
einen boolschen Wert annimmt. Wenn der Wert false ist, geben Sie einen Zeiger Ihres eigenen Fehlertyps
Typs zurück, der wie gewünscht initialisiert wird. Wenn der Wert true ist, wird ein Standardfehler zurückgegeben. Schreiben Sie eine
main-Funktion, die die Funktion checkFlag aufruft und den Fehler über die temporäre
Schnittstelle.

.play error-handling/exercise2.go
.play error-handling/answer2.go

