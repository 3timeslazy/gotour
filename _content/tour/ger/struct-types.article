Struct Types

Struct types sind dafür da, komplexe Typen zu erstellen, die Datenfelder gruppieren.
* Struct Types

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Video anschauen]]
- Brauchst Du finanzielle Hilfe [[https://www.ardanlabs.com/scholarship/][Stipendium]]

Struct types sind dafür da, komplexe Typen zu erstellen, die Datenfelder gruppieren.
Sie sind eine gute Art um Daten zu organisieren und teilen und diese einem Programm zur Verfügung zu stellen.

Das Performance-Potential eines Computers ist vorwiegend durch die word length () und noch wichtiger memory size oder die Anzahl words auf die er zugreifen kann definiert.

** Code Review

- *Aufgabe* *1:* Deklariere, kreiere und initializer einen struct type.
- *Aufgabe* *2:* Anonyme struct typesA.
- *Aufgabe* *3:* Named vs Unnamed types. 
- *Aufgabe* *4:* Struct type Anordnung 

.play struct-types/example1.go
.play struct-types/example2.go
.play struct-types/example3.go
.play struct-types/example4.go

** Stuct und Konstruktions-Mechanismen 
Diese Deklaration representiert einen konkreten benutzerdefinierten Typen als eine Komposition von unterschiedlichen Feldern und Typen.

    type example struct {
        flag    bool
        counter int16
        pi      float32
    }

Deklariere eine Variabel vom Typen example und initilisiere sie mit ihrem zero value state.

    var e1 example

    fmt.Printf("%+v\n", e1)

Output:
    
    {flag:false counter:0 pi:0}

Deklariere eine Variabel vm Typen example ohne den zero value state zu initialisieren. Benutze dafür die literal construction syntax.

    e2 := example{
        flag:    true,
        counter: 10,
        pi:      3.141592,
    }

    fmt.Println("Flag", e2.flag)
    fmt.Println("Counter", e2.counter)
    fmt.Println("Pi", e2.pi)

Output:

    Flag true
    Counter 10
    Pi 3.141592

Deklariere eine Variabel mit einem unnamed literal type und setze den non-zero value state indem Du die literal construction syntax verwendest.

    e3 := struct {
        flag    bool
        counter int16
        pi      float32
    }{
        flag:    true,
        counter: 10,
        pi:      3.141592,
    }

    fmt.Println("Flag", e3.flag)
    fmt.Println("Counter", e3.counter)
    fmt.Println("Pi", e3.pi)

Output:

    Flag true
    Counter 10
    Pi 3.141592

Die Idee von literal construction ist etwas wortwörtlich ohne Namen zu konstruieren

Du solltest var für zero value Deklaration verwende. Die Kurz-Deklaration mit der {} Syntax für non-zero value construction.

** Padding and Angleichung

Wie viel Memory wird für einen Wert vom Typ example alloziert?

    type example struct {
        flag    bool
        counter int16
        pi      float32
    }

Eine bool ist 1 byte, int16 sin 2 bytes, und float32 sind 4 bytes. Zusammen macht das 7 bytes. 
Jedoch: DIe Antwort lautet 8 bytes. Der Grund ist es gib ein padding byte zwischen dem flag und counter Feld, damit die Angleichung stimmt.

.image /tour/eng/static/img/f1.png

Die Idee der Angleichung ist, dass die Hardware Memory effizienter auslesen kann,
indem Memory spezifisch platziert wird. Der Compiler kümmert sich um die Angleichungsmechanik.

Abhängig von der Grösse eines Feldes und seiner Position im struct, bestimmt Go das padding das gebraucht wird.

    type example2 struct {
        flag    bool
        counter int16
        flag2   bool
        pi      float32
    }

In diesem Beispiel, habe ich ein neues Feld namens `flag2` zwischen counter und pi angelegt.
Dies verursacht mehr padding innerhalb des struct.

    type example2 struct {
        flag    bool     // 0xc000100020 <- Starting Address
                byte     // 0xc000100021 <- 1 byte padding
        counter int16    // 0xc000100022 <- 2 byte alignment
        flag2   bool     // 0xc000100024 <- 1 byte alignment
                byte     // 0xc000100025 <- 1 byte padding
                byte     // 0xc000100026 <- 1 byte padding
                byte     // 0xc000100027 <- 1 byte padding
        pi      float32  // 0xc000100028 <- 4 byte alignment
    }

So sieht die Angleichung und das Padding aus, wenn ein Wert vom Typ example2 bei Adresse 0xc000100020 startet.
Das flag Feld representier die Start-Adresse und is nur 1 byte gross. Weil das Counter Feld 2 bytes braucht, muss es im
Memory mit 2-byte angeglichen werden, das heisst es muss auf eine Adresse fallen die ein Vielfaches von 2 ist. 
Damit muss das coutner Feld bei Adresse 0xc000100020 starten. Dies resultiert in einer 1-byte Lücke zwischen flag und counter.

.image /tour/eng/static/img/f2.png

Das `flag2`Feld ist eine bool und kann auf die nächste Adresse fallen 0xc000100024.
Das letze Feld ist Pi und braucht 4 bytes, also muss es auf eine 4-byte Angleichung passen. Die nächste Adresse 
für ein 4byte Wert ist bei 0xc000100028. Das bedeutet plus 3 padding bytes werden gebraucht um eine saubere Angeleichung 
zu gewährleisten. Dies resultiert in einem Wert von 12 bytes für einen Typ example2.

Das grösste Feld in einem struct representiert die Angleichungsgrenze für das gesamte struct.
In diesem Fall ist das grösste Feld 4 bytes gross. Damit muss die Start-Adresse für dieses struct ein Vielfaches von 4 sein.
Du kannst sehen dass die Adresse 0xc000100020 ein Vielfaches von 4 ist.

Wenn Du die Anzahl Padding-bytes minimieren willst, musst Du die Felder so anordnen, dass die höchste Allozierung zuerst 
kommt und die Kleinste zuletzt. Dies stösst notwendige padding bytes ans Ende des struct und reduziert die Anzahl der Padding-bytes.

    type example struct {
        pi      float32  // 0xc000100020 <- Starting Address
        counter int16    // 0xc000100024 <- 2 byte alignment
        flag    bool     // 0xc000100026 <- 1 byte alignment
        flag2   bool     // 0xc000100027 <- 1 byte alignment
    }

Nach der Neuanordnung der Felder, braucht das struct nur noch 8 bytes anstatt 12.
Da alle Felder auf eine 4-byte Angleichung fallen, braucht es kein zusätzliches padding byte.

.image /tour/eng/static/img/f3.png

** Werte zuweisen

Wenn Du zwei verschiedene named types hast, die identisch in ihrer Struktur sind, kann man nicht den Wert des Einen dem Anderen zuweisen.

Zum Beispiel: Wenn die types example1 und example2 genau gleich deklariert und initialisiert werden.

    var ex1 example1
    var ex2 example2

Man kann diese nicht gegenseitig zuweisen, weil sie verschiedene named types sind. 
Die Tatsache dass sie identisch in der Struktur sind, ist irrelevant.

    ex1 = ex2  // Nicht erlaubt, compiler error

Um diese Zuweisung zu machen, muss eine Konversion stattfinden. Weil die Struktur dieselbe ist, wird das vom Compiler erlaubt.

    ex1 = example1(ex2)  // Allowed, NO compiler error

Wenn allerdings ex2 zu einem unnamed type geändert wird, braucht es keine Konversion.

    var ex2 struct {
        flag    bool
        counter int16
        pi      float32
    }

    ex1 = ex2  // Erlaubt, Keine Notwendigkeit für Konversion

Der Compiler erlaubt die Zuweisung ohne Konversion.

** Notizen 
- Wir können die struct literal form zum initialisiern von struct types brauchen.
- Der dot (.) Operator erlaubt uns den Zugriff auf individuelle Feld-Wertek
- Wir können anonyme structs kreieren

** Quotes

"Implicit conversion of types is the Halloween special of coding. Whoever thought
of them deserves their own special hell." - Martin Thompson

** Extra Reading

- [[https://www.ardanlabs.com/blog/2013/07/understanding-type-in-go.html][Understanding Type in Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/07/object-oriented-programming-in-go.html][Object Oriented Programming in Go]] - William Kennedy    
- [[https://dave.cheney.net/2015/10/09/padding-is-hard][Padding is hard]] - Dave Cheney    
- [[https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/][Structure Member Alignment, Padding and Data Packing]]    
- [[http://www.catb.org/esr/structure-packing][The Lost Art of Structure Packing]] - Eric S. Raymond    

* Aufgabe

Benutze das Template als Startpunkt um die Aufgabe zu erfüllen. Eine mögliche Antwort wird bereitgestellt.

** Aufgabe 1

*Teil* *A:* Deklariere ein struct type um Informationen über einen user (name, email, age) zu sammeln.
Kreiere einen Wert dieses Typen, initialisiere mit Werten und gebe jedes Feld aus.

*Teil* *B:* Deklariere und initialisere eine anonymes struct mit denselben 3 Feldern. Gebe die Werte aus.

.play struct-types/exercise1.go
.play struct-types/answer1.go
