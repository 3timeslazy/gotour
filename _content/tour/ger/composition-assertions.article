Typkonvertierungen und Assertionen
Erfahren Sie, wie Typumwandlungen und Assertions funktionieren.

* Typkonvertierungen und Assertionen

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Das Video ansehen]]
- Benötigen Sie finanzielle Unterstützung, nutzen Sie unser [[https://www.ardanlabs.com/scholarship/][Stipendienformular]]

Eine Typkonvertierung ermöglicht die Umwandlung von Daten eines Typs in einen anderen Typ. Eine Typ
Assertion ermöglicht es, die Frage zu stellen, ob ein Wert des angegebenen Typs
innerhalb einer Schnittstelle gespeichert ist.

** Code-Überprüfung

- *Beispiel* *1:* Schnittstellenkonvertierungen
- *Beispiel* *2:* Laufzeittyp-Assertionen
- *Beispiel* *3:* Verhaltensänderungen

.play composition/assertions/example1.go
.play composition/assertions/example2.go
.play composition/assertions/example3.go

** Implizite Schnittstellenumwandlungen

Wie Sie im letzten Beispiel gesehen haben, kann ein Schnittstellenwert eines Typs für einen
anderen Schnittstellentyp übergeben werden, wenn der in der Schnittstelle gespeicherte konkrete Wert
beide Verhaltensweisen implementiert. Dies könnte als implizite Schnittstellenumwandlung betrachtet werden, aber es ist
aber es ist besser, darüber nachzudenken, wie konkrete Daten durch Schnittstellen in einem
entkoppelten Zustand.

    Typ Mover Schnittstelle {
        Move()
    }

    type Locker interface {
        Lock()
        Unlock()
    }

    Typ MoveLocker Schnittstelle {
        Mover
        Locker
    }

Bei diesen drei Schnittstellen ist MoveLocker die Zusammensetzung von Mover und Locker.

    Typ Fahrrad Struktur{}

    func (Fahrrad) Move() {
        fmt.Println("Das Fahrrad wird bewegt")
    }

    func (Fahrrad) Sperren() {
        fmt.Println("Fahrrad abschließen")
    }

    func (Fahrrad) Entriegeln() {
        fmt.Println("Das Fahrrad aufschließen")
    }

Und dann gibt es diesen konkreten Typ Fahrrad, der alle drei Schnittstellen implementiert. Was können Sie tun?

    var ml MoveLocker
    var m Beweger

Sie können einen Wert des Typs MoveLocker und Mover so konstruieren, dass er den Wert Null hat.
Dies sind Schnittstellenwerte, die wirklich wertlos sind.

    ml = Fahrrad{}

Dann können Sie einen Wert des Typs bike in seinen Nullwertzustand konstruieren und eine
Kopie der MoveLocker-Variablen ml zuweisen. Dies ist möglich, weil ein Fahrrad alle drei Verhaltensweisen implementiert
alle drei Verhaltensweisen implementiert, und der Compiler kann erkennen, dass die Implementierung existiert.

    m = ml

Sie können dann die MoveLocker-Variable ml der Mover-Variable m zuweisen. Dies ist möglich
weil ich nicht den Schnittstellenwert ml zuweise, sondern den konkreten Wert, der in ml
von ml, der ein Fahrradwert ist. Der Compiler weiß, dass jeder konkrete Wert, der in
von ml gespeichert ist, auch die Mover-Schnittstelle implementieren muss.

Diese Zuordnung ist jedoch nicht gültig.

    ml = m

Ausgabe:

    kann m (Typ Mover) nicht als Typ MoveLocker in der Zuweisung verwenden:
        Mover implementiert MoveLocker nicht (fehlende Lock-Methode)

Sie können die Mover-Variable m nicht zurück an die MoverLocker-Variable ml zuweisen, weil der
Compiler kann nur garantieren, dass der konkrete Wert, der in m gespeichert ist, weiß, wie man sich bewegt.
Er weiß zur Kompilierungszeit nicht, ob der konkrete Wert auch weiß, wie man sperrt und aufschließt.

** Mechanik der Typbestätigung

Mit einer Typ-Assertion können Sie zur Laufzeit die Frage stellen, ob ein Wert des
gegebenen Typs innerhalb einer Schnittstelle gespeichert. Sie sehen das an der Syntax m.(bike).

    b := m.(Fahrrad)
    ml = b

In diesem Fall fragen Sie, ob zum Zeitpunkt der Ausführung des Codes ein Fahrradwert in m gespeichert ist.
der Code ausgeführt wird. Wenn ja, dann erhält die Variable b eine Kopie des gespeicherten
Wertes gespeichert. Diese Kopie kann dann in die Schnittstellenvariable ml kopiert werden.

Wenn innerhalb des Schnittstellenwerts kein Fahrradwert gespeichert ist, gerät das Programm in Panik.
Sie wollen dies, wenn unbedingt ein Fahrradwert gespeichert sein sollte. Was, wenn es eine
Möglichkeit besteht, dass kein Wert gespeichert ist, und das ist gültig? Dann brauchen Sie die zweite Form der Typbehauptung.

    b, ok := m.(Fahrrad)

In dieser Form ist ein Fahrradwert in der Schnittstelle gespeichert, wenn ok wahr ist. Wenn
ok falsch ist, gibt es keinen Wert und das Programm gerät nicht in Panik. Die Variable b jedoch
ist immer noch vom Typ Fahrrad, aber sie wird auf den Wert Null gesetzt.

    func main() {
        mvs := []fmt.Stringer{
            Auto{},
            Wolke{},
        }

        for i := 0; i < 10; i++ {
            rn := rand.Intn(2)

            if v, is := mvs[rn].(Cloud); is {
                fmt.Println("Habe Glück gehabt:", v)
                weiter
            }

            fmt.Println("Pech gehabt")
        }
    }

Angenommen, das Programm deklariert zwei Typen namens Auto und Wolke, die jeweils die Schnittstelle
die Schnittstelle fmt.Stringer implementieren, können Sie eine Auflistung konstruieren, die es Ihnen ermöglicht, einen
Wert von sowohl Car als auch Cloud speichern können. Dann wählen Sie 10 Mal zufällig eine Zahl zwischen 0 und 1,
und führen eine Typüberprüfung durch, um festzustellen, ob der Wert an diesem Zufallsindex einen
Cloud-Wert enthält. Da es möglich ist, dass der Wert nicht vom Typ Cloud ist, ist die zweite Form der Typ
Behauptung hier entscheidend.
