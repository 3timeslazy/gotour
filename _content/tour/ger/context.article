Context-Paket
Das Paket context definiert den Typ Context, der Fristen, Abbruchsignale und andere anforderungsspezifische Werte über API-Grenzen und zwischen Prozessen überträgt.

* Kontext-Paket

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Das Video ansehen]]
- Benötigen Sie finanzielle Unterstützung, nutzen Sie unser [[https://www.ardanlabs.com/scholarship/][Stipendienformular]]

Das Paket context definiert den Typ Context, der Fristen, Abbruchsignale
Signale und andere anforderungsspezifische Werte über API-Grenzen und zwischen Prozessen transportiert.

** Code-Überprüfung

"Kontextwerte sind für anforderungsspezifische Daten, die Programme in einem verteilten System durchlaufen.
verteilten System durchlaufen.

- *Beispiel* *1:* Werte speichern / abrufen
- *Beispiel* *2:* WithCancel
- *Beispiel* *3:* WithDeadline
- *Beispiel* *4:* MitTimeout
- *Beispiel* *5:* Anfrage/Antwort
- *Beispiel* *6:* Stornierung

.play context/example1.go
.play context/example2.go
.play context/example3.go
.play context/example4.go
.play context/example5.go
.play context/example6.go

** Kontextuelle Semantik

Die Programmiersprache Go verfügt über das eingebaute Schlüsselwort go zur Erstellung von Goroutinen, aber
hat keine Schlüsselwörter oder direkte Unterstützung für das Beenden von Goroutinen. In einem Dienst der realen Welt
ist die Fähigkeit zur Zeitüberschreitung und Beendigung von Goroutinen entscheidend für die Aufrechterhaltung der Gesundheit
und Betrieb eines Dienstes. Keine Anfrage oder Aufgabe kann ewig laufen, daher
Die Identifizierung und Verwaltung von Latenzzeiten ist eine Aufgabe, die jeder Programmierer hat.

Eine vom Go-Team angebotene Lösung für dieses Problem ist das Context-Paket.
Es wurde von Sameer Ajmani geschrieben und bereits 2014 auf der Gotham Go
Konferenz vorgestellt. Er schrieb auch einen Blog-Beitrag für den Go-Blog.

Dia-Deck: [[https://talks.golang.org/2014/gotham-context.slide#1]]https://talks.golang.org/2014/gotham-context.slide#1]

Blog Post: [[https://blog.golang.org/context][https://blog.golang.org/context]]

Aus dieser veröffentlichten Arbeit und aus Gesprächen mit Sameer im Laufe der Jahre
hat sich eine Reihe von Semantiken entwickelt.

*Eingehende* *Anfragen* *an* *einen* *Server* *sollten* *einen* *Kontext* erstellen

Der Zeitpunkt für die Erstellung eines Kontextes ist immer so früh wie möglich in der Bearbeitung einer
Anfrage oder Aufgabe. Die Arbeit mit Kontexten zu einem frühen Zeitpunkt im Entwicklungszyklus zwingt Sie
APIs so zu gestalten, dass sie einen Kontext als ersten Parameter annehmen. Selbst wenn Sie nicht 100%ig sicher sind
sicher sind, dass eine Funktion einen Kontext benötigt, ist es einfacher, den Kontext aus ein paar Funktionen zu entfernen
Funktionen zu entfernen, als zu versuchen, den Kontext später hinzuzufügen.

    75 // Handle ist unser Mechanismus zum Einbinden von Handlern für ein gegebenes HTTP-Verb- und Pfad
    76 // Paar, das macht das Routing sehr einfach und bequem.
    77 func (a *App) Handle(verb, path string, handler Handler, mw ...Middleware) {
    ...
    85 // Die Funktion, die für jede Anfrage ausgeführt werden soll.
    86 h := func(w http.ResponseWriter, r *http.Request, params map[string]string) {
    87 ctx, span := trace.StartSpan(r.Context(), "internal.platform.web")
    88 defer span.End()
    ...
    106 // Füge diesen Handler für das angegebene Verb und die Route hinzu.
    107 a.TreeMux.Handle(verb, path, h)
    108 }

Sie sehen Code aus dem Serviceprojekt, das wir bei Ardan Labs unterrichten. Zeile 86 definiert
eine Handler-Funktion, die an alle Routen gebunden ist, wie in Zeile 107 gezeigt. Es ist diese
Funktion beginnt mit der Verarbeitung aller eingehenden Anfragen. In Zeile 87 wird ein Span erstellt
für die Anfrage erstellt, die als ersten Parameter einen Context erhält. Dies ist das erste Mal
erste Mal, dass im Dienstcode ein Context benötigt wird.

Das Tolle daran ist, dass der Wert http.Request bereits einen Context enthält. Diese
wurde in Version 1.7 von Go hinzugefügt. Das heißt, der Code muss nicht manuell einen
einen Top-Level-Kontext erstellen. Wenn wir Version 1.8 von Go verwenden würden, müssten Sie
einen leeren Context vor dem Aufruf von StartSpan erstellen, indem Sie die Funktion context.Background
Funktion.

    https://golang.org/pkg/context/#Background

    87 ctx := context.Background()
    88 ctx, span := trace.StartSpan(ctx, "internal.platform.web")
    89 defer span.End()

So müsste der Code in Version 1.8 von Go aussehen. Wie es in der
in der Paketdokumentation beschrieben,

Background gibt einen leeren Context zurück, der nicht null ist. Er wird nie abgebrochen, hat keine Werte,
und hat keine Frist. Er wird normalerweise von der Hauptfunktion, der Initialisierung,
und Tests sowie als Top-Level-Kontext für eingehende Anfragen verwendet.

Es ist ein Idiom in Go, den Variablennamen ctx für alle Context-Werte zu verwenden. Da ein
Context eine Schnittstelle ist, sollte keine Zeigersemantik verwendet werden.

    https://golang.org/pkg/context/#Context

    type Context interface {
        Deadline() (Frist time.Time, ok bool)
        Done() <-chan struct{}
        Err() error
        Value(key interface{}) interface{}
    }

Jede Funktion, die einen Context akzeptiert, sollte ihre eigene Kopie des Schnittstellenwertes erhalten.

*Ausgehende* *Aufrufe* *an* *Server* *sollten* *einen* *Kontext* akzeptieren

Die Idee hinter dieser Semantik ist, dass Aufrufe der höheren Ebene den Aufrufen der unteren Ebene mitteilen müssen
Aufrufen mitteilen, wie lange sie zu warten bereit sind. Ein gutes Beispiel dafür ist das http
Paket und die in Version 1.7 vorgenommenen Änderungen an der Do-Methode, um Timeouts bei
einer Anfrage.

    01 Paket Haupt
    02
    03 importieren (
    04 "kontext"
    05 "io"
    06 "log"
    07 "net/http"
    08 "os"
    09 "zeit"
    10 )
    11
    12 func main() {
    13
    14 // Erstellen Sie eine neue Anfrage.
    15 req, err := http.NewRequest("GET", "https://www.ardanlabs.com/blog/post/index.xml", nil)
    16 if err != nil {
    17 log.Println("ERROR:", err)
    18 return
    19 }
    20
    21 // Erstellen eines Kontexts mit einem Timeout von 50 Millisekunden.
    22 ctx, cancel := context.WithTimeout(req.Context(), 50*time.Millisecond)
    23 cancel() aufschieben
    24
    25 // Binden Sie den neuen Kontext in die Anfrage ein.
    26 req = req.WithContext(ctx)
    27
    28 // Führen Sie den Webaufruf durch und geben Sie eventuelle Fehler zurück. Do behandelt das
    29 // Zeitüberschreitung auf Kontextebene.
    30 resp, err := http.DefaultClient.Do(req)
    31 if err != nil {
    32 log.Println("ERROR:", err)
    33 return
    34 }
    35
    36 // Schließen Sie den Antwortkörper bei der Rückkehr.
    37 defer resp.Body.Close()
    38
    39 // Schreibe die Antwort nach stdout.
    40 io.Copy(os.Stdout, resp.Body)
    41 }

Dieses Programm stellt eine Anfrage für den Ardan-RSS-Blog-Feed mit einem Timeout von 50
Millisekunden. In den Zeilen 15-19 wird die Anforderung erstellt, um einen GET-Aufruf an
die angegebene URL. In den Zeilen 22-23 wird ein Context mit einer Zeitüberschreitung von 50 Millisekunden erstellt. A
neue API, die dem Wert Request in Version 1.7 hinzugefügt wurde, ist die Methode WithContext.
Mit dieser Methode kann das Context-Feld des Request-Wertes aktualisiert werden. In Zeile 26,
ist genau das, was der Code tut.

In Zeile 30 wird die eigentliche Anfrage mit der Do-Methode aus dem http-Paket gestellt
DefaultClient Wert. Die Do-Methode beachtet den Timeout-Wert von 50 Millisekunden
der jetzt innerhalb des Kontexts im Wert Request festgelegt ist. Was Sie hier sehen, ist der
Code (Funktion auf höherer Ebene), der der Do-Methode (Funktion auf niedrigerer Ebene) mitteilt, wie lange
wir bereit sind zu warten, bis der Do-Vorgang abgeschlossen ist.

*Do* *not* *store* *Contexts* *inside* *a* *struct* *type*

Stattdessen übergeben Sie einen Context explizit an jede Funktion, die ihn benötigt. Im Wesentlichen sollte jede
Funktion, die E/A durchführt, einen Context-Wert als ersten Parameter akzeptieren
akzeptieren und alle vom Aufrufer konfigurierten Zeitüberschreitungen oder Fristen einhalten. Im Fall von Request,
waren Fragen der Rückwärtskompatibilität zu berücksichtigen. Anstatt also die APIs zu ändern,
wurde die im letzten Abschnitt beschriebene Mechanik implementiert.

Für jede Regel gibt es Ausnahmen. Aber im Rahmen dieses Beitrags und aller
API's aus der Standardbibliothek, die einen Context annehmen, ist es üblich, dass der erste
Parameter den Context-Wert akzeptiert.

.image /tour/eng/static/img/context_figure1.png

Die Abbildung zeigt ein Beispiel aus dem Netzpaket, bei dem der erste Parameter jeder
Methode einen Context als ersten Parameter annimmt und den ctx-Variablennamen als Idiom verwendet.

*Die* *Kette* *von* *Funktionsaufrufen* *zwischen* *muss* *den* *Kontext* *weitergeben*

Dies ist eine wichtige Regel, da ein Kontext anfrage- oder aufgabenbasiert ist. Sie möchten, dass der
Kontext und alle daran vorgenommenen Änderungen während der Bearbeitung der Anfrage oder Aufgabe
weitergegeben und beachtet werden.

    23 // List gibt alle im System vorhandenen Benutzer zurück.
    24 func (u *User) List(ctx context.Context, w http.ResponseWriter, r *http.Request, params map[string]string) error {
    25 ctx, span := trace.StartSpan(ctx, "handlers.User.List")
    26 defer span.End()
    27
    28 users, err := user.List(ctx, u.db)
    29 if err != nil {
    30 return err
    31 }
    32
    33 return web.Respond(ctx, w, users, http.StatusOK)
    34 }

In diesem Listing sehen Sie eine Handler-Funktion namens List, die ausgeführt wird, wenn ein
Benutzer eine HTTP-Anfrage für diesen Endpunkt stellt. Der Handler akzeptiert als seinen ersten
Parameter einen Context, da er Teil einer Anfrage ist und E/A durchführen wird. Sie können
Sie können in den Zeilen 25, 28 und 33 sehen, dass derselbe Context-Wert auf dem
Aufrufstapel weitergegeben wird.

Ein neuer Context-Wert wird nicht erstellt, da diese Funktion keine Änderungen an ihm erfordert.
Würde durch diese Funktion ein neuer Top-Level-Kontextwert erstellt, würden alle vorhandenen
Kontextinformationen aus einem mit dieser Anfrage verbundenen Aufruf auf höherer Ebene
verloren gehen. Dies ist nicht erwünscht.

    33 // List holt eine Liste der vorhandenen Benutzer aus der Datenbank.
    34 func List(ctx context.Context, db *sqlx.DB) ([]User, error) {
    35 ctx, span := trace.StartSpan(ctx, "internal.user.List")
    36 defer span.End()
    37
    38 Benutzer := []Benutzer{}
    39 const q = `SELECT * FROM users`
    40
    41 if err := db.SelectContext(ctx, &users, q); err != nil {
    42 return nil, errors.Wrap(err, "selecting users")
    43 }
    44
    45 return users, nil
    46 }

Sie sehen die Deklaration der Methode List, die in Zeile 28 aufgerufen wurde. Auch hier
nimmt diese Methode einen Context als ersten Parameter an. Dieser Wert wird dann
in den Zeilen 35 und 41 erneut den Aufrufstapel hinunter. Da Zeile 41 ein Datenbankaufruf ist,
sollte diese Funktion alle Timeout-Informationen respektieren, die im Context von
einem der obigen Aufrufer.

*Ersetzen* *eines* *Kontexts* *mit* *WithCancel,* *WithDeadline,* * *WithTimeout,* * *oder* *WithValue*

Da jede Funktion den Kontext für ihre spezifischen Bedürfnisse hinzufügen/verändern kann und
diese Änderungen sich nicht auf eine zuvor aufgerufene Funktion auswirken sollten, verwendet der Context
eine Wertesemantik. Das bedeutet, dass jede Änderung an einem Context-Wert einen neuen Context
Wert, der dann weitergegeben wird.

    01 func main() {
    02
    03 // Setzt eine Dauer.
    04 Dauer := 150 * Zeit.Millisekunde
    05
    06 // Erzeuge einen Kontext, der sowohl manuell abbrechbar ist als auch ein Signal
    07 // Abbruch bei der angegebenen Dauer signalisiert.
    08 ctx, cancel := context.WithTimeout(context.Background(), duration)
    09 cancel() aufschieben
    10
    11 // Erstellen Sie einen Kanal, um ein Signal zu erhalten, dass die Arbeit erledigt ist.
    12 ch := make(chan data, 1)
    13
    14 // Fordern Sie die Goroutine auf, etwas für uns zu tun.
    15 go func() {
    16
    17 // Arbeit simulieren.
    18 time.Sleep(50 * time.Millisekunde)
    19
    20 // Melden, dass die Arbeit erledigt ist.
    21 ch <- Daten{"123"}
    22 }()
    23
    24 // Warte, bis die Arbeit beendet ist. Wenn es zu lange dauert, mach weiter.
    25 select {
    26 case d := <-ch:
    27 fmt.Println("Arbeit beendet", d)
    28
    29 case <-ctx.Done():
    30 fmt.Println("Arbeit abgebrochen")
    31 }
    32 }

Dies ist ein kleines Programm, das die wertesemantische Natur der WithTimeout
Funktion zeigt. In Zeile 08 gibt der Aufruf von WithTimeout einen neuen Context-Wert und eine
Abbrechen-Funktion. Da der Funktionsaufruf einen übergeordneten Context erfordert, verwendet der Code
die Funktion Background, um einen leeren Context der obersten Ebene zu erstellen. Dies ist der Zweck der
Hintergrundfunktion.

Im weiteren Verlauf wird der mit der Funktion WithTimeout erstellte Context-Wert verwendet. Wenn
zukünftige Funktionen in der Aufrufkette ihre eigene spezifische Zeitüberschreitung oder Frist benötigen,
sollten sie ebenfalls die entsprechende With-Funktion und diesen neuen Context-Wert als
den übergeordneten Wert verwenden.

Es ist von entscheidender Bedeutung, dass jede Abbruchfunktion, die von einer With-Funktion
zurückgegeben wird, ausgeführt wird, bevor diese Funktion zurückkehrt. Aus diesem Grund ist es üblich, das Schlüsselwort defer
Schlüsselwort direkt nach dem With-Aufruf zu verwenden, wie Sie in Zeile 26 sehen. Wenn Sie dies nicht tun, führt dies zu
Speicherlecks in Ihrem Programm.

*Wenn *ein* *Kontext* *abgebrochen* wird, *werden* alle* *Kontexte*, die *von* diesem *abgeleitet* sind, *auch* abgebrochen*.

Die Verwendung der Wertesemantik für die Context-API bedeutet, dass jeder neue Context-Wert
alles, was der übergeordnete Context hat, sowie alle neuen Änderungen. Das bedeutet, wenn ein
übergeordneter Kontext abgebrochen wird, werden alle Kinder, die von diesem übergeordneten Kontext
ebenfalls abgebrochen.

    01 func main() {
    02
    03 // Erstellen Sie einen Kontext, der abgebrochen werden kann.
    04 ctx, cancel := context.WithCancel(context.Background())
    05 cancel() aufschieben
    06
    07 // Verwenden Sie die Waitgroup für die Orchestrierung.
    08 var wg sync.WaitGroup
    09 wg.Add(10)
    10
    11 // Erstellen Sie zehn Goroutinen, die einen Context von
    12 // dem oben erstellten ableiten.
    13 for i := 0; i < 10; i++ {
    14 go func(id int) {
    15 defer wg.Done()
    16
    17 // Leiten Sie einen neuen Context für diese Goroutine von dem Context
    18 // den die Hauptfunktion besitzt.
    19 ctx := context.WithValue(ctx, key, id)
    20
    21 // Warten, bis der Context abgebrochen wird.
    22 <-ctx.Done()
    23 fmt.Println("Abgebrochen:", id)
    24 }(i)
    25 }
    26
    27 // Abbrechen des Kontexts und aller abgeleiteten Kontexte.
    28 cancel()
    29 wg.Wait()
    30 }

Dieses Programm erstellt einen Kontextwert, der in Zeile 04 gelöscht werden kann. Dann werden in
Zeilen 13-25 werden zehn Goroutinen erstellt. Jede Goroutine platziert ihre eindeutige ID
in ihren eigenen Context-Wert in Zeile 19. Dem Aufruf von WithValue wird der
Context-Wert der Hauptfunktion als Elternteil übergeben. Dann, in Zeile 22, wartet jede Goroutine
bis ihr Context abgebrochen wird.

In Zeile 28 löscht die Haupt-Goroutine ihren Kontextwert und wartet dann in Zeile 29
darauf, dass alle zehn Goroutinen das Signal erhalten, bevor das Programm beendet wird.
Sobald die Funktion cancel aufgerufen wird, werden alle zehn Goroutinen in Zeile 41
freigegeben und drucken aus, dass sie abgebrochen wurden. Ein Aufruf von cancel bricht
sie alle.

Dies zeigt auch, dass ein und derselbe Kontext an Funktionen übergeben werden kann, die in verschiedenen
goroutinen laufen. Ein Context ist für die gleichzeitige Verwendung durch mehrere Goroutinen sicher.

Übergeben Sie keinen "nil"-Kontext, auch wenn eine Funktion dies zulässt. Übergeben Sie einen TODO-Kontext, wenn
Sie unsicher sind, welchen Context Sie verwenden sollen. Einer meiner Lieblingsteile des Context
Pakets ist die TODO-Funktion. Ich bin der festen Überzeugung, dass ein Programmierer immer
Code entwirft. Das ist nicht anders als ein Schriftsteller, der Versionen eines Artikels entwirft.
Artikels. Man weiß nie alles, wenn man Code schreibt, aber hoffentlich weiß man genug
um die Dinge voranzubringen. Letztendlich lernen Sie ständig dazu, überarbeiten und
Testen auf dem Weg.

Es gab viele Momente, in denen ich wusste, dass ich einen Kontext brauchte, aber nicht wusste, woher er
woher er kommen würde. Ich wusste, dass ich nicht für die Erstellung des Top-Level-Kontextes verantwortlich war
zu erstellen, also kam die Background-Funktion nicht in Frage. Ich brauchte einen temporären
Top-Level-Context, bis ich herausgefunden hatte, woher der eigentliche Context kommen würde.
In diesem Fall sollten Sie die TODO-Funktion über die Background-Funktion verwenden.

*Verwendung* von *Kontext* *Werten* *nur* *für* *anforderungsspezifische* *Daten*

Verwenden Sie den Context nicht für die Übergabe optionaler Parameter an Funktionen. Dies ist vielleicht
die wichtigste Semantik von allen. Verwenden Sie den Context-Wert nicht zur Übergabe von Daten an
eine Funktion zu übergeben, wenn diese Daten von der Funktion benötigt werden, um ihren Code erfolgreich auszuführen.
Mit anderen Worten: Eine Funktion sollte in der Lage sein, ihre Logik mit einem leeren Context
Wert ausführen können. In Fällen, in denen eine Funktion Informationen im Context-Wert benötigt, sollte das Programm fehlschlagen, wenn diese
Informationen fehlen, sollte das Programm fehlschlagen und die Anwendung zum Herunterfahren auffordern.

Ein klassisches Beispiel für den Missbrauch der Übergabe von Daten in einen Funktionsaufruf mittels Context
ist mit Datenbankverbindungen. Als allgemeine Regel sollten Sie diese Reihenfolge einhalten, wenn Sie
Daten in Ihrem Programm bewegen.

Übergeben Sie die Daten als Funktionsparameter Dies ist der einfachste Weg, um Daten im Programm zu bewegen
Programm zu bewegen, ohne sie zu verstecken.

Übergabe der Daten durch den Empfänger Wenn die Funktion, die die Daten benötigt, nicht
Signatur der Funktion, die die Daten benötigt, nicht geändert werden kann, verwenden Sie eine Methode und übergeben Sie die Daten über den Empfänger.

Schnelles Beispiel für die Verwendung eines Empfängers

Request-Handler sind ein klassisches Beispiel für die zweite Regel. Da eine Handler-Funktion
an eine bestimmte Deklaration gebunden ist, kann die Signatur des Handlers nicht geändert werden.

    23 // List gibt alle im System vorhandenen Benutzer zurück.
    24 func (u *User) List(ctx context.Context, w http.ResponseWriter, r *http.Request, params map[string]string) error {
    25 ctx, span := trace.StartSpan(ctx, "handlers.User.List")
    26 defer span.End()
    27
    28 users, err := user.List(ctx, u.db)
    29 if err != nil {
    30 return err
    31 }
    32
    33 return web.Respond(ctx, w, users, http.StatusOK)
    34 }

Hier sehen Sie die List-Handler-Methode aus dem Service-Projekt. Die Signatur von
dieser Methoden sind an die vom Web-Framework definierten Methoden gebunden und können nicht
geändert werden. Für den Geschäftsaufruf in Zeile 28 ist jedoch eine Datenbankverbindung
erforderlich. Dieser Code findet den Verbindungspool nicht über den Context-Wert, der
sondern aus dem Empfänger.

    15 // User steht für den Satz der Benutzer-API-Methodenhandler.
    16 type User struct {
    17 db *sqlx.DB
    18 authenticator *auth.Authenticator
    19
    20 // FÜGEN SIE HIER ANDERE ZUSTÄNDE WIE DEN LOGGER UND DIE KONFIGURATION HINZU.
    21 }

Sie sehen die Deklaration des Empfängertyps. Alles, was ein Request-Handler benötigt
benötigt, wird als Felder definiert. Dies ermöglicht, dass Informationen nicht versteckt werden und dass die Business
Schicht mit einem leeren Kontextwert funktionieren kann.

    14 // API konstruiert einen http.Handler mit allen definierten Anwendungsrouten.
    15 func API(shutdown chan os.Signal, log *log.Logger, db *sqlx.DB, authenticator *auth.Authenticator) http.Handler {
    16
    ...
    26 // Benutzerverwaltung und Authentifizierungsendpunkte registrieren.
    27 u := Benutzer{
    28 db: db,
    29 authenticator: authenticator,
    30 }
    31
    32 app.Handle("GET", "/v1/users", u.List)

Dieser Code konstruiert einen Benutzerwert und bindet dann die Methode List in die Route ein.
Da die Signatur einer Handler-Funktion nicht geändert werden kann, ist auch hier die Verwendung eines
Empfänger und Methoden die nächstbeste Möglichkeit, Daten zu übergeben, ohne dass sie versteckt werden.

*Debugging* *oder* *Tracing* *Daten* *sind* *sicher* *in* *einem* *Kontext* zu übergeben

Daten, die von einem Context-Wert gespeichert und empfangen werden können, sind Debug- und Tracing-Informationen.

    23 // Werte stellen den Zustand für jede Anfrage dar.
    24 type Werte struct {
    25 TraceID string
    26 Jetzt Zeit.Zeit
    27 StatusCode int
    28 }

Hier ist eine Deklaration eines Typs, der in jedem Context
Wert, der für eine neue Anfrage erstellt wird. Die drei Felder liefern Tracing- und Debugging
Informationen für die Anfrage. Diese Informationen werden im Verlauf der Anfrage gesammelt.

    75 // Handle ist unser Mechanismus zum Einbinden von Handlern für ein gegebenes HTTP-Verb- und Pfad
    76 // Paar, das macht das Routing sehr einfach und bequem.
    77 func (a *App) Handle(verb, path string, handler Handler, mw ...Middleware) {
    78
    ...
    79 // Die Funktion, die für jede Anfrage ausgeführt werden soll.
    80 h := func(w http.ResponseWriter, r *http.Request, params map[string]string) {
    ...
    84 // Setzt den Kontext mit den erforderlichen Werten, um
    85 // Verarbeitung der Anfrage.
    86 v := Werte{
    87 TraceID: span.SpanContext().TraceID.String(),
    88 Now: time.Now(),
    89 }
    90 ctx = context.WithValue(ctx, KeyValues, &v)

Sehen Sie sich an, wie der Typ Values in Zeile 86 konstruiert und dann im Context
in Zeile 90 gespeichert wird. Die meisten dieser Informationen werden von der Middleware für die Protokollierung benötigt.

    20 // Erstellen Sie den Handler, der in der Middleware-Kette angehängt werden soll.
    21 h := func(ctx context.Context, w http.ResponseWriter, r *http.Request, params map[string]string) error {
    ...
    25 // Wenn der Kontext diesen Wert nicht enthält, fordern Sie den Dienst
    26 // dass der Dienst ordnungsgemäß heruntergefahren wird.
    27 v, ok := ctx.Value(web.KeyValues).(*web.Values)
    28 if !ok {
    29 return web.NewShutdownError("Webwert fehlt im Kontext")
    30 }
    ...
    34 log.Printf("%s : (%d) : %s %s -> %s (%s)",
    35 v.TraceID, v.StatusCode,
    36 r.Methode, r.URL.Pfad,
    37 r.RemoteAddr, time.Since(v.Now),
    38 )

Die Folgen der Weitergabe von Informationen durch den Kontext werden im Code in
Zeilen 27-30. Der Code versucht, die Wertedaten aus dem Kontext abzurufen
abzurufen und zu prüfen, ob die Daten vorhanden sind. Wenn die Daten nicht vorhanden sind, liegt ein schwerwiegendes
Integritätsproblem vor und der Dienst muss heruntergefahren werden. Dies geschieht im Code des Dienstes durch
indem ein spezieller Fehlerwert über die Anwendung zurückgeschickt wird.

Wenn Sie Datenbankverbindungen oder Benutzerinformationen über einen Context in Ihre Business
Schicht mit Hilfe eines Contexts übergeben, haben Sie zwei Probleme:

- Sie müssen die Integrität prüfen und brauchen einen Mechanismus, um den Dienst schnell abzuschalten.
- Das Testen und Debuggen wird viel schwieriger und komplizierter. Sie verzichten auf mehr Klarheit und Lesbarkeit in Ihrem Code.

** Anmerkungen

- Eingehende Anfragen an einen Server sollten einen Context erstellen.
- Ausgehende Aufrufe an Server sollten einen Context akzeptieren.
- Die Kette von Funktionsaufrufen zwischen ihnen muss den Context weitergeben.
- Ersetzen Sie einen Context mit WithCancel, WithDeadline, WithTimeout oder WithValue.
- Wenn ein Context abgebrochen wird, werden alle von ihm abgeleiteten Contexte ebenfalls abgebrochen.
- Speichern Sie Kontexte nicht innerhalb eines Strukturtyps; übergeben Sie stattdessen einen Kontext explizit an jede Funktion, die ihn benötigt.
- Übergeben Sie keinen Context mit dem Wert Null, auch wenn eine Funktion dies zulässt. Übergeben Sie context.TODO, wenn Sie sich nicht sicher sind, welchen Context Sie verwenden sollen.
- Verwenden Sie Context Values nur für anforderungsspezifische Daten, die Prozesse und APIs durchlaufen, und nicht für die Übergabe optionaler Parameter an Funktionen.
- Derselbe Context kann an Funktionen übergeben werden, die in verschiedenen Goroutinen laufen; Contexte sind sicher für die gleichzeitige Verwendung durch mehrere Goroutinen.

** Extra Lesen

- [[https://www.ardanlabs.com/blog/2019/09/context-package-semantics-in-go.html][Kontextpaket-Semantik in Go]] - William Kennedy
- [[https://golang.org/pkg/context][Paketkontext]] - Go-Team
- [[https://blog.golang.org/context][Go-Gleichzeitigkeitsmuster: Kontext]] - Sameer Ajmani
- [[https://rakyll.org/leakingctx/][Verwendung von Kontexten zur Vermeidung undichter Goroutinen]] - JBD

* Übungen

Verwenden Sie die Vorlage als Ausgangspunkt, um die Aufgaben zu lösen. Eine mögliche Lösung ist angegeben.

** Übung 1

Verwenden Sie die Vorlage und folgen Sie den Anweisungen. Sie werden einen Web-Handler schreiben, der einen Mock-Datenbankaufruf durchführt, aber eine Zeitüberschreitung basierend auf einem Kontext verursacht, wenn der Aufruf zu lange dauert. Sie werden auch den Zustand im Kontext speichern.

.play context/exercise1.go
.play context/answer1.go

