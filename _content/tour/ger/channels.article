Kanäle
Kanäle ermöglichen es Goroutinen, durch die Verwendung von Signalisierungssemantiken miteinander zu kommunizieren.

* Kanäle

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Das Video ansehen]]
- Benötigen Sie finanzielle Unterstützung, nutzen Sie unser [[https://www.ardanlabs.com/scholarship/][Stipendienformular]]

Es ist wichtig, einen Kanal nicht als eine Datenstruktur zu betrachten, sondern als einen Mechanismus zur
Signalisierung. Dies entspricht der Vorstellung, dass man über einen Kanal sendet und empfängt,
nicht lesen und schreiben. Wenn das Problem, vor dem man steht, nicht mit Signalisierung gelöst werden kann,
wenn Sie das Wort Signalisierung nicht in den Mund nehmen, müssen Sie die Verwendung von
Kanälen hinterfragen.

** Code-Überprüfung

- *Beispiel* *1:* Warten auf das Ergebnis
- *Beispiel* *2:* Auffächern
- *Beispiel* *3:* Warten auf Aufgabe
- *Beispiel* *4:* Pooling
- *Beispiel* *5:* Semaphor auffächern
- *Beispiel* *6:* Bounded work pooling
- *Beispiel* *7:* Drop
- *Beispiel* *8:* Annullierung
- *Beispiel* *9:* Retry Timeout
- *Beispiel* *10:* Kanalabbruch

.play channels/example1.go
.play channels/example2.go
.play channels/example3.go
.play channels/example4.go
.play channels/example5.go
.play channels/example6.go
.play channels/example7.go
.play channels/example8.go
.play channels/example9.go
.play channels/example10.go

** Kanalmechanik

Der Preis für die Garantie auf der Signalisierungsebene ist eine unbekannte Latenzzeit. Der
Sender weiß nicht, wie lange er warten muss, bis der Empfänger das Signal akzeptiert.
Das Warten auf den Empfänger führt zu einer Blockierlatenz. In diesem Fall sind unbekannte
Mengen an blockierender Latenz. Der Sender muss für eine unbekannte Zeitspanne warten,
bis der Empfänger für den Empfang des Signals bereit ist.

Warten auf den Empfänger bedeutet mechanisch, dass der Empfangsvorgang vor dem Senden erfolgt.
dem Senden. Bei Kanälen erfolgt der Empfang Nanosekunden vorher, aber es ist vorher.
Das bedeutet, dass der Empfänger das Signal entgegennimmt und dann weggeht, so dass der Absender
nun mit einer Garantie weitermachen kann.

Was ist, wenn der Prozess nicht für eine unbekannte Zeitspanne warten kann? Was ist, wenn diese Art von
Latenzzeit nicht funktionieren wird? Dann kann die Garantie nicht auf der Signalisierungsebene liegen, sie muss
muss außerhalb davon liegen. Die Mechanik dahinter ist, dass das Senden nun vor dem
vor dem Empfang. Der Sender kann das Signal ausführen, ohne dass der Empfänger
verfügbar sein muss. Der Sender muss also nicht mehr warten, sondern kann gehen. Irgendwann, so hofft man,
taucht der Empfänger auf und nimmt das Signal entgegen.

Dadurch werden zwar die Latenzkosten beim Senden reduziert, aber es entsteht Unsicherheit über die Signale
die empfangen werden, und damit auch, ob es Probleme mit den Empfängern im Vorfeld gibt.
Dies kann dazu führen, dass Arbeit angenommen wird, die nie begonnen oder beendet wird. Es
könnte schließlich zu einem massiven Rückstau und einem Systemabsturz führen.

Der zweite Punkt, auf den Sie sich konzentrieren sollten, ist, ob Sie mit dem Signal Daten senden müssen. Wenn das Signal
die Übertragung von Daten erfordert, dann ist die Signalisierung ein 1 zu 1 zwischen Goroutinen.
Wenn eine neue Goroutine das Signal auch empfangen muss, muss ein zweites Signal gesendet werden.

Wenn keine Daten mit dem Signal übertragen werden müssen, kann das Signal ein 1-to
1 oder 1 zu vielen zwischen Goroutinen sein. Die Signalisierung ohne Daten wird hauptsächlich für
Stornierungen oder Abschaltungen. Dies geschieht durch Schließen des Kanals.

Der dritte Punkt, auf den man sich konzentrieren sollte, ist der Kanalstatus. Ein Kanal kann sich in einem von 3 Zuständen befinden.

Ein Kanal kann sich in einem Null-Zustand befinden, indem der Kanal in den Null-Wert-Zustand konstruiert wird.
Das Senden und Empfangen von Kanälen in diesem Zustand wird blockiert. Dies ist gut für Situationen
in denen Sie kurzfristige Arbeitsunterbrechungen implementieren möchten.

Ein Kanal kann mit der eingebauten Funktion make in einen offenen Zustand versetzt werden. Sendungen und
Empfangen gegen Kanäle in diesem Zustand funktionieren unter den folgenden Bedingungen:

*Ungepuffert* *Kanäle:*

- Garantien auf der Ebene der Signalisierung, wobei der Empfang vor dem Senden erfolgt. Das Senden von
und Empfangs-Goroutinen müssen im selben Raum und zur selben Zeit zusammenkommen, damit ein
Signal verarbeitet werden kann.

*Gepuffert* *Kanäle:*

- Garantien außerhalb der Signalisierungsebene, wobei das Senden vor dem
Empfang. Wenn der Puffer nicht voll ist, können die Sendungen abgeschlossen werden, sonst werden sie blockiert. Wenn der
Puffer nicht leer ist, kann der Empfang abgeschlossen werden, sonst blockiert er.

Ein Kanal kann mit der eingebauten Funktion close geschlossen werden. Sie brauchen nicht
müssen einen Kanal nicht schließen, um Speicher freizugeben, sondern nur, um den Zustand zu ändern. Das Senden von
an einen geschlossenen Kanal führt zu einer Panik, der Empfang an einen geschlossenen Kanal
kehrt sofort zurück.

Mit all diesen Informationen können Sie sich auf die Kanalmuster konzentrieren. Die Konzentration auf die Signalisierung
ist wichtig. Es geht darum, ob Sie eine Garantie auf der Signalisierungsebene benötigen oder nicht,
aufgrund von Latenzproblemen. Ob Sie Daten mit dem Signal übertragen müssen oder nicht, basierend auf
der Behandlung von Stornierungen oder nicht. Sie wollen die Syntax in diese Semantik umwandeln.

** Gestaltungsrichtlinien

- Informieren Sie sich über die [[https://github.com/ardanlabs/gotraining/blob/master/topics/go/#channel-design]]-Gestaltungsrichtlinien]] für Kanäle.

** Diagramme

*Garantie* *für* die *Lieferung*

Die "Liefergarantie" basiert auf einer Frage: "Brauche ich eine Garantie, dass
das von einer bestimmten Goroutine gesendete Signal empfangen wurde?"

.image /tour/eng/static/img/garantie_der_lieferung.png

*Signalisierung* *Mit* *Oder* *Ohne* *Daten*

Wenn Sie ein Signal "mit" Daten senden wollen, können Sie zwischen drei Kanalkonfigurationen
Optionen, die Sie je nach der Art der benötigten "Garantie" wählen können.

.image /tour/eng/static/img/signaling_with_data.png

Die Signalisierung ohne Daten dient dem Hauptzweck der Annullierung. Sie erlaubt einer
goroutine einer anderen goroutine zu signalisieren, ihre Arbeit abzubrechen und fortzufahren.
Die Stornierung kann sowohl mit "ungepufferten" als auch mit "gepufferten" Kanälen implementiert werden.

.image /tour/eng/static/img/signaling_without_data.png

*Staat*

Das Verhalten eines Kanals wird direkt von seinem aktuellen "Zustand" beeinflusst. Der
Zustand eines Kanals kann `nil`, `open` oder `closed` sein.

.image /tour/eng/static/img/state.png

** Extra Lesen

- [[https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html][Das Verhalten von Kanälen]] - William Kennedy
- [[https://golang.org/ref/mem#tmp_7][Kanalkommunikation]]
- [[http://blog.golang.org/share-memory-by-communicating][Gemeinsame Erinnerung durch Kommunikation]] - Andrew Gerrand
- [[https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html][Die Natur von Kanälen in Go]] - William Kennedy
- [[http://matt-welsh.blogspot.com/2010/07/retrospective-on-seda.html][Eine Retrospektive zu SEDA]] - Matt Welsh
- [[https://www.youtube.com/watch?v=KBZlN0izeiY][Das Verständnis von Kanälen]] - Kavya Joshi

** Pufferblähung - 2011

Seien Sie vorsichtig bei der Verwendung von großen Puffern, um die Latenzzeit zu verringern.

- Große Puffer verhindern eine rechtzeitige Meldung des Staudrucks.
- Sie verhindern, dass Sie den Rückstau rechtzeitig abbauen können.
- Sie können die Latenzzeit erhöhen, anstatt sie zu verringern.
- Verwenden Sie gepufferte Kanäle, um die Kontinuität zu gewährleisten.
- Verwenden Sie sie nicht nur aus Leistungsgründen.
- Verwenden Sie sie, um genau definierte Datenbursts zu verarbeiten.
- Nutzen Sie sie zur Bewältigung von Problemen mit der Lichtgeschwindigkeit zwischen Übergaben.

*Videos*

- [[https://www.youtube.com/watch?v=qbIozKVz73g][Bufferbloat: Dunkle Puffer im Internet]]
- [[http://www.bufferbloat.net/projects/cerowrt/wiki/Bloat-videos][Buffer Bloat Videos]]

* Übungen

Verwenden Sie die Vorlage als Ausgangspunkt, um die Aufgaben zu lösen. Eine mögliche Lösung ist angegeben.

** Übung 1

Schreiben Sie ein Programm, in dem zwei Goroutinen eine ganze Zahl zehnmal hin- und herschieben.
Zeigen Sie an, wann jede Goroutine die ganze Zahl erhält. Erhöhe die ganze Zahl bei jedem
Durchlauf. Sobald die ganze Zahl zehn beträgt, beende das Programm sauber.

.play channels/exercise1.go
.play channels/answer1.go

** Übung 2

Schreiben Sie ein Programm, das mit Hilfe eines Auffächerungsmusters 100 Zufallszahlen gleichzeitig erzeugt.
Jede Goroutine soll eine einzelne Zufallszahl erzeugen und diese über einen gepufferten Kanal an die Haupt
goroutine über einen gepufferten Kanal zurück. Legen Sie die Größe des Pufferkanals so fest, dass keine Sendung jemals
blockiert. Weisen Sie nicht mehr Puffer zu, als Sie brauchen. Lassen Sie die Haupt-Goroutine jede
jede empfangene Zufallszahl anzeigen und dann das Programm beenden.

.play channels/exercise2.go
.play channels/answer2.go

** Übung 3

Schreiben Sie ein Programm, das bis zu 100 Zufallszahlen gleichzeitig erzeugt. Senden Sie nicht
nicht alle 100 Werte, so dass die Anzahl der Sende-/Empfangsvorgänge unbekannt ist.

.play channels/exercise3.go
.play channels/answer3.go
 
** Übung 4

Schreiben Sie ein Programm, das mit Hilfe eines Worker-Pools bis zu 100 Zufallszahlen gleichzeitig erzeugt
Pool. Lehnen Sie gerade Werte ab. Weisen Sie die Arbeiter an, abzuschalten, wenn 100 ungerade Zahlen
gesammelt wurden.

.play channels/exercise4.go
.play channels/answer4.go
