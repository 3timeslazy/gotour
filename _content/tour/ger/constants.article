Konstanten
Eine der einzigartigeren Eigenschaften von Go ist die Art und Weise, wie die Sprache Konstanten implementiert.

* Konstanten

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Das Video ansehen]]
- Benötigen Sie finanzielle Unterstützung, nutzen Sie unser [[https://www.ardanlabs.com/scholarship/][Stipendienformular]]

Eine der besonderen Eigenschaften von Go ist die Art und Weise, wie die Sprache Konstanten implementiert.
Die Regeln für Konstanten in der Sprachspezifikation sind einzigartig für Go. Sie bieten
die Flexibilität, die Go braucht, um den Code, den wir schreiben, lesbar und intuitiv zu machen und gleichzeitig
Typensicherheit zu gewährleisten.

Konstanten können typisiert oder untypisiert sein. Wenn eine Konstante nicht typisiert ist, wird sie als
einer Art. Konstanten eines Typs können vom Compiler implizit konvertiert werden. Diese
geschieht zur Kompilierzeit und nicht zur Laufzeit.

** Code-Überprüfung

- *Beispiel* *1:* Deklaration und Initialisierung von Konstanten
- *Beispiel* *2:* Paralleles Typsystem (Kind) (fehlt)
- *Beispiel* *3:* iota
- *Beispiel* *4:* Implizite Konvertierung

.play constants/example1.go
.play constants/example2.go
.play constants/example3.go
.play constants/example4.go

    const ui = 12345 // Art: Ganzzahl
    const uf = 3.141592 // Art: Gleitkomma

Untypisierte numerische Konstanten haben eine Genauigkeit von 256 Bit, wie in der Spezifikation angegeben.
Sie basieren auf einer Art.

    const ti int = 12345 // Typ: int
    const tf float64 = 3.141592 // Typ: float64

Typisierte Konstanten verwenden immer noch das Konstanten-Typ-System, aber ihre Genauigkeit ist eingeschränkt.

    const myUint8 uint8 = 1000 // Compilerfehler: Konstante 1000 überläuft uint8

Das funktioniert nicht, weil die Zahl 1000 zu groß ist, um sie in einem uint8 zu speichern.

    var Antwort = 3 * 0,333 // float64 = KindFloat(3) * KindFloat(0,333)

Die Konstantenarithmetik unterstützt die Verwendung verschiedener Arten von Konstanten. Die Art Promotion
wird verwendet, um diese verschiedenen Szenarien zu behandeln. All dies geschieht implizit. Die Antwort
Variable in diesem Beispiel ist vom Typ float64 und repräsentiert 0,999 mit einer Genauigkeit
von 64 Bit.

    const third = 1 / 3.0 // KindFloat = KindFloat(1) / KindFloat(3.0)

Die dritte Konstante ist vom Typ Float und steht für 1/3 mit einer Genauigkeit von 256 Bit.

    const zero = 1 / 3 // KindInt = KindInt(1) / KindInt(3)

Die Nullkonstante ist vom Typ Ganzzahl und wird auf 0 gesetzt, da die Ganzzahldivision
keinen Rest hat.

    const eins int8 = 1
    const zwei = 2 * eins // int8(2) * int8(1)

Dies ist ein Beispiel für Konstantenarithmetik zwischen typisierten und nicht typisierten Konstanten.
In diesem Fall hat eine Konstante eines Typs Vorrang vor einer Konstante eines Typs. Die beiden
Konstanten sind vom Typ int8 und werden auf 2 gesetzt.

    const maxInt = 9223372036854775807

Dies ist der maximale ganzzahlige Wert für eine 64-Bit-Ganzzahl.

    const bigger = 9223372036854775808543522345

Die größere Konstante ist ein viel größerer Wert als eine 64-Bit-Ganzzahl, aber sie kann
in einer Konstante der Art int gespeichert werden, da Konstanten der Art int nicht auf
64 Bit Genauigkeit beschränkt sind.

    const größer int64 = 9223372036854775808543522345

Compiler-Fehler:

    Konstante 9223372036854775808543522345 Überläufe int64

Wäre bigger jedoch eine Konstante vom Typ int64, ließe sich dies nicht kompilieren.

** IOTA

IOTA bietet Unterstützung für das Setzen von aufeinanderfolgenden Integer-Konstanten. Es ist möglich, dass der
Name stammt von der Integer-Funktion ⍳ aus der Programmiersprache APL. In APL,
wird die Funktion ⍳ (dargestellt durch den neunten Buchstaben des griechischen Alphabets, iota)
ein nullbasiertes Array aus aufeinanderfolgenden, aufsteigenden ganzen Zahlen einer bestimmten
Länge.

    const (
        A1 = iota // 0 : Beginn bei 0
        B1 = iota // 1 : Erhöhen um 1
        C1 = iota // 2 : Erhöhen um 1
    )
    fmt.Println(A1, B1, C1)

Ausgabe:

    0 1 2

Das Schlüsselwort iota funktioniert innerhalb eines Konstantenblocks und beginnt mit dem Wert 0. Dann
für jede weitere Konstante, die in dem Block deklariert wird, erhöht sich iota um 1.

    const (
        A2 = iota // 0 : Beginn bei 0
        B2 // 1 : Erhöhen um 1
        C2 // 2 : Inkrementierung um 1
    )
    fmt.Println(A2, B2, C2)

Ausgabe:

    0 1 2

Die Verwendung des Schlüsselworts iota muss nicht wiederholt werden. Die sukzessive Natur der
ganzzahligen Konstanten wird nach einmaliger Anwendung angenommen.

    const (
        A3 = iota + 1 // 1 : 0 + 1
        B3 // 2 : 1 + 1
        C3 // 3 : 2 + 1
    )
    fmt.Println(A3, B3, C3)

Ausgabe:

    1 2 3

Wenn Sie kein mathematisches Muster anwenden möchten, können Sie eine Berechnung durchführen und die
Mathematik wird mit einem steigenden Wert von iota erneut angewandt.

    const (
        Ldate= 1 << iota // 1 : Verschiebung 1 nach links 0. 0000 0001
        Ltime // 2 : Verschiebung von 1 nach links 1.  0000 0010
        Lmicroseconds // 4 : Verschiebung 1 nach links 2.  0000 0100
        Llongfile // 8 : Verschiebung 1 nach links 3.  0000 1000
        Lshortfile // 16 : Verschiebung 1 nach links 4.  0001 0000
        LUTC // 32 : Verschiebung um 1 nach links 5.  0010 0000
    )

    fmt.Println(Ldate, Ltime, Lmicroseconds, Llongfile, Lshortfile, LUTC)

Ausgabe:

    1 2 4 8 16 32

Sie können diese Funktion wie das Log-Paket zum Setzen von Flaggen verwenden. In diesem Fall werden Bit
Operationen mit aufsteigenden Iota-Werten angewandt, um Merkerwerte zu berechnen.

** Anmerkungen

- Konstanten sind keine Variablen.
- Sie existieren nur bei der Kompilierung.
- Untypisierte Konstanten können implizit konvertiert werden, was bei typisierten Konstanten und Variablen nicht möglich ist.
- Betrachten Sie untypisierte Konstanten als eine Art, nicht als einen Typ.
- Erfahren Sie mehr über explizite und implizite Konvertierungen.
- Sehen Sie die Macht der Konstanten und ihre Verwendung in der Standardbibliothek.

** Extra Lesen

- [[https://golang.org/ref/spec#Constants][Konstanten-Spezifikation]]
- [[https://blog.golang.org/constants][Konstanten]] - Rob Pike
- [[https://www.ardanlabs.com/blog/2014/04/introduction-to-numeric-constants-in-go.html][Einführung in numerische Konstanten in Go]] - William Kennedy
		
* Übungen

Verwenden Sie die Vorlage als Ausgangspunkt, um die Aufgaben zu lösen. Eine mögliche Lösung ist angegeben.

** Übung 1

*Teil* *A:* Deklarieren Sie eine untypisierte und typisierte Konstante und zeigen Sie deren Werte an.

*Teil* *B:* Teilen Sie zwei literale Konstanten in eine typisierte Variable und zeigen Sie den Wert an.

.play constants/exercise1.go
.play constants/answer1.go
