Exportieren
Exportieren bietet die Möglichkeit zu deklarieren, ob ein Bezeichner für Code außerhalb des Pakets, in dem er deklariert ist, zugänglich ist.

* Exportieren

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Das Video ansehen]]
- Benötigen Sie finanzielle Unterstützung, nutzen Sie unser [[https://www.ardanlabs.com/scholarship/][Stipendienformular]]

Exportieren bietet die Möglichkeit zu deklarieren, ob ein Bezeichner für Code
außerhalb des Pakets, in dem er deklariert ist, zugänglich ist.

** Code-Überprüfung

- *Beispiel* *1:* Deklaration und Zugriff auf exportierte Bezeichner
- *Beispiel* *2:* Nicht exportierte Bezeichner und Einschränkungen deklarieren
- *Beispiel* *3:* Zugriff auf Werte von nicht exportierten Bezeichnern
- *Beispiel* *4:* Nicht exportierte Felder vom Typ struct
- *Beispiel* *5:* Nicht exportierte eingebettete Typen

.play exporting/example1.go
.play exporting/example2.go
.play exporting/example3.go
.play exporting/example4.go
.play exporting/example5.go

** Mechanik exportieren

Ein Paket ist die Grundeinheit des kompilierten Codes in Go. Es repräsentiert eine physische kompilierte
Einheit von Code, normalerweise als kompilierte Bibliothek auf dem Host-Betriebssystem. Der Export von
bestimmt den Zugriff auf Bezeichner über Paketgrenzen hinweg.

    Paketzähler

    Typ AlertCounter int

Da in diesem Fall ein Großbuchstabe verwendet wird, um den Typ AlterCounter,
ist der Typ exportiert und kann direkt von Code außerhalb des
Zähler-Paket referenziert werden.

    Paketzähler

    Typ alertCounter int

Da Sie nun den Namen des Typs so geändert haben, dass er mit einem Kleinbuchstaben beginnt, ist der Typ
nicht exportiert. Das bedeutet, dass nur Code innerhalb des Zählerpakets auf diesen
Typ direkt referenzieren.

    Paketzähler

    Typ alertCounter int

    func New(wert int) alertCounter {
        return alertCounter(wert)
    }

Obwohl der obige Code eine legale Syntax aufweist und kompiliert werden kann, hat er keinen Wert.
Die Rückgabe eines Wertes eines nicht exportierten Typs ist verwirrend, da der Aufrufer (der
wahrscheinlich in einem anderen Paket existiert) den Typnamen nicht direkt referenzieren kann.

    Paket Haupt

    importieren (
        "fmt"

        "github.com/ardanlabs/.../exporting/example3/counters"
    )

    func main() {
        Zähler := Zähler.Neu(10)
        fmt.Printf("Zähler: %d\n", Zähler)
    }

In diesem Fall ruft die Hauptfunktion im Paket main die Funktion counters.New
erfolgreich auf und der Compiler kann eine Variable des nicht exportierten
Typs deklarieren und konstruieren. Das bedeutet weder, dass Sie dies tun sollten, noch, dass Sie einen echten
Schutz für dieses Vorgehen. Dies sollte vermieden werden, und wenn New einen Wert zurückgibt, sollte dieser
sollte er von einem exportierten Typ sein.

    Paketnutzer

    Typ Benutzer struct {
        Name string
        ID int

        passwort string
    }

Wenn es um Felder in einer Struktur geht, gibt der erste Buchstabe an, ob das Feld
für Code außerhalb des Pakets, in dem es deklariert ist, zugänglich ist. In diesem Fall sind Name
und ID zugänglich, aber Passwort nicht. Es ist eine Redewendung, exportierte
und nicht exportierte Felder auf diese Weise zu trennen, wenn dies sinnvoll oder praktisch ist.
Normalerweise würden alle Felder entweder das eine oder das andere sein.

    Paketnutzer

    Typ user struct {
        Name string
        ID int
    }

    type Manager struct {
        Titel string
        Benutzer
    }

In diesem Szenario hat der Benutzertyp, obwohl er nicht exportiert wird, zwei exportierte
Felder. Das bedeutet, dass die Benutzerfelder beim Einbetten des Benutzertyps in den exportierten Managertyp
Typ eingebettet ist, werden die Benutzerfelder gefördert und sind zugänglich. Es ist üblich, dass Typen, die
mit exportierten Feldern, weil das Reflection-Paket nur auf exportierte Felder
auf exportierte Felder arbeiten kann. Marshallers werden sonst nicht funktionieren.

Das Beispiel schafft eine schlechte Situation, in der Code außerhalb von Paketbenutzern einen Manager konstruieren kann
einen Manager konstruieren kann, aber da der eingebettete Typ user nicht exportiert wird, können die Felder für diesen Typ
initialisiert werden können. Dies führt zu partiellen Konstruktionsproblemen, die zu Fehlern führen.
Sie müssen beim Exportieren und Nichtexportieren konsistent sein.

** Anmerkungen

- Der Code in go wird in Pakete kompiliert und dann miteinander verknüpft.
- Bezeichner werden auf der Grundlage der Groß- und Kleinschreibung exportiert (oder bleiben unexportiert).
- Wir importieren Pakete, um auf exportierte Bezeichner zuzugreifen.
- Jedes Paket kann einen Wert eines nicht exportierten Typs verwenden, aber das ist lästig.

** Extra Lesen

[[https://www.ardanlabs.com/blog/2014/03/exportedunexported-identifiers-in-go.html][Exportierte/nicht exportierte Bezeichner in Go]] - William Kennedy

* Übungen

Verwenden Sie die Vorlage als Ausgangspunkt, um die Aufgaben zu lösen. Eine mögliche Lösung ist angegeben.

** Übung 1

*Teil* *A:* Erstellen Sie ein Paket namens toy mit einem einzigen exportierten struct-Typ namens Toy.
Fügen Sie die exportierten Felder Name und Weight hinzu. Dann fügen Sie zwei nicht exportierte Felder namens onHand
und sold. Deklarieren Sie eine Factory-Funktion namens New, um Werte vom Typ toy zu erzeugen und
Parameter für die exportierten Felder akzeptiert. Deklarieren Sie dann Methoden, die Werte zurückgeben und aktualisieren
für die nicht exportierten Felder.

*Teil* *B:* Erstellen Sie ein Programm, das das Spielzeugpaket importiert. Verwenden Sie die Funktion New, um
einen Wert vom Typ toy zu erzeugen. Verwenden Sie dann die Methoden, um die Zählerstände zu setzen und die
Feldwerte dieses toy-Wertes.

.play exporting/exercise1.go
.play exporting/answer1.go
