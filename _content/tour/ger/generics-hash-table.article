Hash-Tabellen
Eine Hash-Tabelle ist ein klassisches Beispiel für einen Containertyp, der die Vorteile der Generika wirklich nutzen kann.

* Generika - Hashtabellen

Eine Hashtabelle ist ein klassisches Beispiel für einen Containertyp, der die Vorteile der
Generika nutzen kann. Diese Implementierung wurde von Matt Layher (@mdlayer) in einem Blogbeitrag
geschrieben. Sie ist ein großartiges Beispiel dafür, was mit Generika möglich ist.

** Video

Schauen Sie sich den Vortrag über Generics an, der Sie durch alle
Beispiele in diesem Abschnitt der Tour.

.html generics-video.html

** Code-Überprüfung

- *Beispiel* *1*: Hash-Tabelle

.play generics/hash-table/example1.go

** Erläutert

Dieser Code ist etwas komplexer als das, was Sie bisher haben. Es ist das, was Sie
Implementierungen in der Praxis zu erwarten. In diesem Abschnitt werden Sie
zwei Ansichten des Codes sehen. Eine vor und eine nach der Anwendung der neuen Syntax für
Generika.

    type hashFunc func(key K, buckets int) int

Dieser Typ deklariert eine Hash-Funktionssignatur, die von der Hash-Tabelle verwendet wird, um
eine Bucket-Position für die Speicherung und den Abruf von Daten zu berechnen. Der Benutzer muss diese Funktion implementieren
und diese Funktion bereitstellen, wenn er eine Hash-Tabelle konstruiert. Die Funktion akzeptiert einen
Schlüssel und die Anzahl der Buckets, aus denen sie wählen kann. Da Sie wollen, dass dieses System
generisch sein soll, was die für Schlüssel und Wert verwendeten Typen angeht, deklarieren Sie einen Parameter
mit dem Namen key an, dessen Typ der einzelne Großbuchstabe K ist.

Als Nächstes können Sie die Generika-Syntax anwenden, um K zu einem echten generischen Typ zu machen.

    type hashFunc[K comparable] func(key K, buckets int) int <-- CHANGED

Nach dem Typnamen fügen Sie die eckigen Klammern mit dem generischen Typ K und einer
Einschränkung von vergleichbar. Da die Werte des Schlüsseltyps in einer
Vergleichsoperation verwendet werden müssen, ist es jetzt sinnvoll, dies zu dokumentieren, auch wenn die
Implementierung der Hash-Funktion dies nicht erfordert. Konsistenz ist alles in Bezug auf
Lesbarkeit, Verständlichkeit und Wartbarkeit im Laufe der Zeit.

Dieser Typ steht für ein Schlüssel/Wert-Paar von Daten, die in der Hashtabelle gespeichert werden sollen.

    type keyValuePair struct {
        Schlüssel K
        Wert V
    }

Die Aufgabe dieses Typs ist es, die aktuellen Daten mit dem entsprechenden Schlüssel zu speichern. Als nächstes deklariert der
Code ein Schlüsselfeld des Typs K und ein Wertfeld des Typs V deklariert.

Jetzt können Sie die Syntax der Generika anwenden, um K und V zu einem echten generischen Typ zu machen.

    type keyValuePair[K vergleichbar, V beliebig] struct { <-- CHANGED
        Schlüssel K
        Wert V
    }

Fügen Sie nach dem Typnamen die eckigen Klammern mit den generischen Typen K und V hinzu.
dieser Deklaration steht K wie zuvor für den Schlüssel und V für einen Wert, der
alles sein kann.

Dieser Typ stellt eine Hash-Tabelle dar, die eine Hash-Funktion und eine Reihe von
Bereichen für die Speicherung von Schlüssel/Wertdaten verwaltet.

    type Tabelle struct {
        hashFunc hashFunc
        buckets int
        data [][]keyValuePair
    }

Der Typ Tabelle hat drei Felder, eine Hash-Funktion, die Anzahl der Eimer und die
Daten, die als ein Slice eines Slice von Schlüssel/Wert-Paaren dargestellt werden. Das äußere Slice
repräsentiert Buckets und das innere Slice repräsentiert Schlüssel/Wertpaare, die in einem Bucket gespeichert sind.
innerhalb eines Buckets gespeichert sind.

Wenden Sie nun die Syntax der Generika an, um die generischen Schlüssel- und Werttypen zu deklarieren und
sie auf die Felddeklarationen anzuwenden.

    type Tabelle[K vergleichbar, V beliebig] struct { <-- CHANGED
        hashFunc hashFunc[K] <-- CHANGED
        buckets int
        data [][]keyValuePair[K, V] <-- CHANGED
    }

Fügen Sie nach dem Typnamen die eckigen Klammern mit den generischen Typen K und V hinzu.
hashFunc-Typdeklaration erfordert Informationen über den konkreten Typ, der für
den Schlüssel. Die Deklaration des Typs keyValuePair erfordert Informationen über den konkreten
Typ für den Schlüssel und den Wert.

Dies ist eine Fabrikfunktion, die eine Tabelle zur Verwendung konstruieren kann.

    func New(
        Eimer int,
        hf hashFunc
    ) *Table {
        
        return &Table{
            hashFunc: hf,
            buckets: buckets,
            data: make([][]keyValuePair, buckets),
        }
    }

Die Factory-Funktion akzeptiert die Anzahl der zu verwaltenden Buckets und eine Hash-Funktion
zur Auswahl eines Bereichs für die Datenspeicherung und -suche. Wenn ein Tabellenwert
konstruiert wird, wird die Anzahl der Eimer verwendet, um das Slice zu konstruieren, wobei die Länge
des äußeren Slice auf die Anzahl der zu verwendenden Buckets gesetzt.

Wenden Sie nun die Syntax der Generika an, um die generischen Schlüssel- und Werttypen zu deklarieren und
sie auf die zu konstruierenden Typen anzuwenden.

    func New[K comparable, V any]( <-- CHANGED
        buckets int,
        hf hashFunc[K], <-- CHANGED
    ) *Table[K, V] { <-- CHANGED
        
        return &Table[K, V]{ <-- GEÄNDERT
            hashFunc: hf,
            buckets: buckets,
            data: make([][]keyValuePair[K, V], buckets), <-- CHANGED
        }
    }

Fügen Sie nach dem Typnamen die eckigen Klammern und die generischen Typen K und V hinzu.
K wird auf den Eingabeparameter hf angewendet, um die Deklaration des Typs hashFunc zu vervollständigen.
Die Typen K und V werden auf den Typ Table angewandt, der konstruiert und zurückgegeben wird.
Schließlich erfordert die Initialisierung des Datenfelds die Anwendung von K und V auf die
Konstruktionssyntax für den Typ keyValuePair.

Dies ist eine Methode, mit der Werte in die Hashtabelle auf der Grundlage eines bestimmten Schlüssels eingefügt werden können.

    type Tabelle[K vergleichbar, V beliebig] struct {
        hashFunc hashFunc[K]
        buckets int
        table [][]keyValuePair[K, V]
    }

    func (t *Table) Insert(key K, value V) {
        bucket := t.hashFunc(Schlüssel, t.buckets)
        for idx, kvp := range t.table[bucket] {
            if Schlüssel == kvp.Schlüssel {
                t.table[bucket][idx].Value = value
                return
            }
        }

        kvp := keyValuePair{
            Schlüssel: key,
            Wert: Wert,
        }
        t.table[bucket] = append(t.table[bucket], kvp)
    }

Die Insert-Methode ist so deklariert, dass sie einen Schlüssel und einen Wert der gleichen generischen Typen akzeptiert
die mit dem Typ Table deklariert sind. Der erste Schritt des Einfügens ist die Identifizierung des
Bucket für die Speicherung zu verwenden. Dies geschieht durch den Aufruf der Hash-Funktion mit dem
angegebenen Schlüssel. Die Hash-Funktion gibt einen Integer-Wert zurück, der den zu verwendenden Bucket
zu verwenden ist.

Dann prüft die Funktion, ob der angegebene Schlüssel bereits verwendet wurde, um
einen Wert im ausgewählten Bereich zu speichern. Dazu wird der vorhandene Satz von
Schlüssel/Wert-Paaren im Bereich. Wenn der Schlüssel bereits existiert, wird der Wert für diesen Schlüssel
aktualisiert. Wird der Schlüssel nicht gefunden, wird ein neuer Wert für das Schlüssel/Wert-Paar erstellt,
initialisiert und an das Slice für den ausgewählten Bucket angehängt.

Wenden Sie nun die Syntax der Generika an, um die generischen Schlüssel- und Werttypen zu deklarieren und
sie auf die zu konstruierenden Typen anzuwenden.

    func (t *Table[K, V]) Insert(key K, value V) { <-- CHANGED
        bucket := t.hashFunc(key, t.buckets)
        for idx, kvp := range t.table[bucket] {
            if key == kvp.Key {
                t.table[bucket][idx].Value = value
                return
            }
        }
    
        kvp := keyValuePair[K, V]{ <-- GEÄNDERT
            Schlüssel: key,
            Wert: Wert,
        }
        t.table[bucket] = append(t.table[bucket], kvp)
    }

Fügen Sie nach dem Typnamen im Empfänger die eckigen Klammern und die generischen
Typen K und V. Die einzige weitere Änderung besteht darin, K und V auf die Konstruktionssyntax
des Typs keyValuePair anzuwenden.

Dies ist eine Methode, die Werte aus der Hash-Tabelle auf der Grundlage eines angegebenen Schlüssels abrufen kann.
Schlüssel.

    func (t *Table) Retrieve(key K) (V, bool) {
        bucket := t.hashFunc(schlüssel, t.buckets)
        for idx, kvp := range t.data[bucket] {
            if Schlüssel == kvp.Schlüssel {
                return t.data[bucket][idx].Value, true
            }
        }
    
        var null V
        return zero, false
    }

Die Retrieve-Methode ist so deklariert, dass sie einen Schlüssel akzeptiert und eine Kopie des Wertes zurückgibt
zurück, der für diesen Schlüssel gespeichert ist. Der erste Schritt des Abrufs besteht darin, den Bereich zu identifizieren, der
für die Speicherung verwendet wurde. Dies geschieht durch den Aufruf der Hash-Funktion mit dem angegebenen
Schlüssel. Die Hashfunktion gibt einen ganzzahligen Wert zurück, der den zu untersuchenden Bereich darstellt.
an.

Anschließend durchläuft die Funktion die Sammlung von Schlüssel/Wertpaaren, die im
Bucket gespeichert sind, und sucht nach dem angegebenen Schlüssel, eins nach dem anderen. Wenn der Schlüssel gefunden wird, wird eine Kopie des
Wertes zurückgegeben und true an den Aufrufer übermittelt. Wenn der Schlüssel nicht gefunden wird, wird Null
Wert zurückgegeben und false an den Aufrufer übermittelt.

Wenden Sie nun die Syntax der Generika an, um die generischen Schlüssel- und Werttypen zu deklarieren und
sie auf die zu konstruierenden Typen anzuwenden.

    func (t *Table[K, V]) Get(key K) (V, bool) { <-- CHANGED
        bucket := t.hashFunc(key, t.buckets)
        for idx, kvp := range t.data[bucket] {
            if key == kvp.Key {
                return t.data[bucket][idx].Value, true
            }
        }
    
        var null V
        return zero, false
    }

Fügen Sie nach dem Typnamen im Empfänger die eckigen Klammern und die generischen
Typen K und V hinzu. Weitere Codeänderungen sind nicht erforderlich.

Dies ist ein kleines Programm, um die Implementierung der Hashtabelle zu testen.

    func main() {
        const Eimer = 8
        . . .
    }

Beginnen Sie mit einer Konstante, die die Anzahl der in der Hashtabelle zu verwendenden Eimer definiert.

    importieren (
        "hash/fnv"
    )
    
    func main() {
        . . .
        
        hashFunc1 := func(key string, buckets int) int {
            h := fnv.New32()
            h.Write([]byte(Schlüssel))
            return int(h.Sum32()) % buckets
        }

        . . .
    }

Als nächstes deklarieren Sie eine Hash-Funktion, die eine Zeichenkette als Schlüssel deklariert. Die
Implementierung verwendet das fnv-Paket aus der Standardbibliothek, das die
FNV-1 und FNV-1a implementiert, nicht kryptographische Hash-Funktionen, die von Glenn Fowler,
Landon Curt Noll und Phong Vo. FNV steht für die Fowler-Noll-Vo-Hash-Funktion.

Die Modulus-Operation mit dem Eimerwert erzwingt, dass der Endwert in den Bereich
den Bereich für die Anzahl der Bereiche fallen.

    importieren (
        "hash/fnv"
    )
    
    func main() {
        . . .
        
        table1 := New[/*key*/ string, /*value*/ int](buckets, hashFunc1)
        
        . . .
    }

Als Nächstes konstruieren Sie eine Hashtabelle, wobei Sie ausdrücklich angeben, dass der Schlüssel vom Typ string
und der Wert vom Typ int ist. Es gibt nichts in den Eingabeparametern, das dem Compiler helfen könnte
Compiler diese Information ableiten kann.

Um zu zeigen, dass es sich bei der Hash-Tabelle um eine generische Tabelle handelt, wurde eine zweite Hash
Funktion und Tabelle.

    importieren (
        "hash/fnv"
    )
    
    func main() {
        . . .
    
        hashFunc2 := func(key int, buckets int) int {
            return key % buckets
        }

        table2 := New[/*key*/ int, /*value*/ string](buckets, hashFunc2)
    
        . . .
    }

Diese Hash-Funktion deklariert eine ganze Zahl als Schlüssel und führt eine einfache Modulus
Operation mit dem Bucket-Wert gegen den Schlüssel durch. Dann wird eine neue Tabelle erstellt
erstellt, in der der Schlüssel als Ganzzahl und der Wert als Zeichenkette angegeben ist. Die Umkehrung der
der ersten Tabelle.


    importieren (
        "hash/fnv"
    )
    
    func main() {
        . . .
    
        words := []string{"foo", "bar", "baz"}
        for i, word := range words {
            table1.Insert(wort, i)
            table2.Insert(i, wort)
        }
    
        for i, s := range append(words, "nope!") {
            v1, ok1 := table1.Retrieve(s)
            fmt.Printf("t1.Rtr(%v) = (%v, %v)\n", s, v1, ok1)
            
            v2, ok2 := table2.Retrieve(i)
            fmt.Printf("t2.Rtr(%v) = (%v, %v)\n", i, v2, ok2)
        }
    }

Ausgabe:

    t1.Rtr(foo) = (0, true)
    t2.Rtr(0) = (foo, true)
    t1.Rtr(bar) = (1, wahr)
    t2.Rtr(1) = (bar, true)
    t1.Rtr(baz) = (2, true)
    t2.Rtr(2) = (baz, true)
    t1.Rtr(nope!) = (0, falsch)
    t2.Rtr(3) = (, false)

Schreiben Sie schließlich einen Code zum Speichern und Abrufen von Werten aus den beiden entsprechenden
Tabellen.
