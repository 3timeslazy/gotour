Mocking
Da der Compiler eine statische Codeanalyse durchführen kann, um festzustellen, ob ein konkreter Wert eine Schnittstelle implementiert, muss der Entwickler, der den konkreten Typ deklariert, nicht auch noch Schnittstellen bereitstellen.

* Spott

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Das Video ansehen]]
- Benötigen Sie finanzielle Unterstützung, nutzen Sie unser [[https://www.ardanlabs.com/scholarship/][Stipendienformular]]

Der beste Weg, die Vorteile der Einbettung zu nutzen, ist das kompositorische Design
Muster. Die Idee ist, größere Typen aus kleineren Typen zusammenzusetzen und sich auf die
Komposition des Verhaltens.

** Code-Überprüfung

- *Beispiel* *1:* Spott

.play composition/mocking/example1.go

** Eigentum an der Schnittstelle

Eine Sache, die sich in Go von anderen Sprachen unterscheidet, ist die Idee, dass Konventionen
vor der Konfiguration. Dies zeigt sich besonders daran, wie Go die Einhaltung von Schnittstellen handhabt.
Da der Compiler eine statische Codeanalyse durchführen kann, um festzustellen, ob ein konkreter Wert
eine Schnittstelle implementiert, muss der Entwickler, der den konkreten Typ deklariert, nicht
Schnittstellen bereitzustellen.

    Paket pubsub

    Typ PubSub struct {
        host string
    }

    func New(host string) *PubSub {
        return &PubSub{
            host: host,
        }
    }

    func (ps *PubSub) Publish(key string, v interface{}) error {
        // VORGEBEN, DASS ES EINE BESTIMMTE IMPLEMENTIERUNG GIBT.
        return nil
    }

    func (ps *PubSub) Subscribe(key string) error {
        // VORGEBEN, DASS ES EINE BESTIMMTE IMPLEMENTIERUNG GIBT.
        return nil
    }

Sie haben gerade eine neue API implementiert, die eine konkrete Implementierung für Publish
und abonnieren bietet. Es werden keine Schnittstellen bereitgestellt, da diese API keine
braucht. Dies ist eine einzige konkrete Implementierung.

Was ist, wenn der Anwendungsentwickler, der diese neue API verwenden möchte, eine Schnittstelle benötigt
benötigt, weil er diese Implementierung während der Tests nachbilden muss? In Go kann der
Entwickler die Schnittstelle deklarieren und der Compiler kann die Konformität erkennen.

    Paket Haupt

    type publisher interface {
        Publish(key string, v interface{}) error
        Subscribe(key string) error
    }

    Typ mock struct{}

    func (m *mock) Publish(key string, v interface{}) error {
        // FÜGE MEINEN MOCK FÜR DEN PUBLISH-AUFRUF HINZU.
        return nil
    }

    func (m *mock) Subscribe(key string) error {
        // FÜGE MEIN MOCK FÜR DEN SUBSCRIBE-AUFRUF HINZU.
        return nil
    }

Dieser Code im Hauptpaket deklariert eine Schnittstelle. Diese Schnittstelle repräsentiert
die API, die die Anwendung aus dem pubsub-Paket verwendet. Der Entwickler hat
seine eigene pubsub-Implementierung zu Testzwecken implementiert. Der Schlüssel hier ist, dass dieser
Anwendungsentwickler keine konkrete Implementierung direkt verwendet, sondern sich über
durch seine eigene Schnittstelle.

    func main() {
        pubs := []publisher{
            pubsub.New("localhost"),
            &mock{},
        }

        for _, p := range pubs {
            p.Publish("Schlüssel", "Wert")
            p.Subscribe("Schlüssel")
        }
    }

Um ein Beispiel zu geben, konstruiert die Hauptfunktion eine Sammlung, die initialisiert wird
mit der pubsub-Implementierung und der mock-Implementierung initialisiert wird. Die Publisher-Schnittstelle
ermöglicht dies. Dann wird eine for range-Schleife implementiert, um zu zeigen, wie der Anwendungscode
von jeder konkreten Implementierung abstrahiert wird.
