Slices

Slices sind eine unglaublich wichtige Datenstruktur in Go. Sie sind die Basis für einen flexiblen, performanten und dynamischen Umgang mit Datenkontrolle und Datenmanipulation. Es ist von unschöpfbarem Wert für alle Go Programmierer den Umgang mit Slices zu erlernen und anzuwenden.

* Slices

- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Schau das Video]]
- Need Financial Assistance, Use Our [[https://www.ardanlabs.com/scholarship/][Scholarship Form]]


Slices sind eine unglaublich wichtige Datenstruktur in Go. Sie sind die Basis für einen flexiblen, performanten und dynamischen Umgang mit Datenkontrolle und Datenmanipulation. Es ist von unschöpfbarem Wert für alle Go Programmierer den Umgang mit Slices zu erlernen und anzuwenden.


.image /tour/eng/static/img/sl1.png

** Code Review 

- *Example* *1:* Deklaration und Länge
- *Example* *2:* Reference Typen
- *Example* *3:* Slices erweitern
- *Example* *4:* Slices von slices nehmen
- *Example* *5:* Slices und Referenzen 
- *Example* *6:* Strings und slices
- *Example* *7:* Variadic Funktionen
- *Example* *8:* Range Mechanismen 
- *Example* *9:* Effiziente Traversierung 
- *Example* *10:* Drei Index Slices

.play slices/example1.go
.play slices/example2.go
.play slices/example3.go
.play slices/example4.go
.play slices/example5.go
.play slices/example6.go
.play slices/example7.go
.play slices/example8.go
.play slices/example9.go 
.play slices/example10.go

** Slice Konstruktion 

Ein Slice kann auf verschiedene Arten kreiert werden.

    // Slice von string mit zero value initialisiert
    var slice []string

    // Slice von string leer initialisiert
    slice := []string{}

    // Slice von string mit einer Länge und Kapazität von 5
    slice := make([]string, 5)

    // Slice von string mit einer Länge von 5 und einer Kapazität von 8
    slice := make([]string, 5, 8)

    // Slice von string mit Werten initialisiert mit einer Länge und einer Kapazität von 5
    slice := []string{"A", "B", "C", "D", "E"}


Wie Du sehen kannst, kann man die built-in Funktion make benutzen um Länge und Kapazität des backing Array Vorzuallozieren.
Wenn der Compiler die Grösse zu compile time kennt, kann das backing Array auf dem Stack konstruiert werden.

** Slice Länge vs Kapazität

Die Länge eines slice representiert die Anzahl Elemente die in ein slice gelesen bzw. geschrieben werden können.
Die Kapazität representiert die Anzahl Elemente die im korrespondierenden backing array von der Pointer Position aus.

Aufgrund von syntactic sugar, sehen slices aus wie arrays.

    slice := make([]string, 5)
    slice[0] = "Apple"
    slice[1] = "Orange"
    slice[2] = "Banana"
    slice[3] = "Grape"
    slice[4] = "Plum"

Der Unterschied zwischen einem Slice und einem Array ist, dass die Grösse des Arrays schon zu compile-time bekannt ist, 
während dies auf die Grösse des Slice nicht unbedingt zutriffe.

Wenn Du versuchst auf ein Element ausserhalb der Länge des Slice zuzugrifen gibt es einen runtime error.

    slice := make([]string, 5)
    slice[5] = "Raspberry"

Compiler Error:

    Error: panic: runtime error: index out of range slice[5] = "Runtime error"

In diesem Beispiel ist die Länge des Slice 5 und Ich versuche auf das 6te Element zuzugriefen, welches nicht existiert.

** Daten Semantaik Guideline für Slices

Als Guideline zählt: Wenn die Daten mit denen ich arbeite ein slice sind, brauche ich value semantics um die Daten innerhalb des Programms zu bewegen.
Dies zählt auch für das Deklarieren von Feldern eines Typen.

    func Foo(data []byte) []byte

    type Foo struct {
        X []int
        Y []string
        Z []bool
    }

Dies zählt für alle internen Daten Strukturen von Go (slices, maps, channels, interfaces and functions)

Ein Grund um auf pointer semantic zu wechseln ist wenn der slice für Dekodierungs- oder Unmarshaling-Operationen geshared werden muss.
Für solche Operationen ist es okay pointers zu verwenden, es sollte aber dokumentiert werden, wenn es nicht offensichtlich ist.

** Contiguous Memory Layout

Die Idee hinter einem Slice ist ein Array zu haben, denn das Array is die effizienteste Datenstruktur die direkt der Hardware zugeordnet werden kann.
Gleichzeitig brauchen wir aber die Möglichkeit um dynamisch und effizient eine Vergrösserung der Anzahl Daten die wir zu runtime brauchen zu machen. 

    func main() {
        slice := make([]string, 5, 8)
        slice[0] = "Apple"
        slice[1] = "Orange"
        slice[2] = "Banana"
        slice[3] = "Grape"
        slice[4] = "Plum"

        inspectSlice(slice)
    }

    func inspectSlice(slice []string) {
        fmt.Printf("Length[%d] Capacity[%d]\n", len(slice), cap(slice))
        for i := range slice {
            fmt.Printf("[%d] %p %s\n", i, &slice[i], slice[i])
        }
    }

Output:

    Length[5] Capacity[8]
    [0] 0xc00007e000 Apple
    [1] 0xc00007e010 Orange
    [2] 0xc00007e020 Banana
    [3] 0xc00007e030 Grape
    [4] 0xc00007e040 Plum

Die Funktion inspectSlice zeigt, dass ein Slice ein zusammenhängendes Backing Array hat
mit einer vorhersehbaren Schrittweite hat. Sie zeigt auch, dass ein Slice eine Länge und Kapazität hat
die unterschiedlich sein können. Die Funktion print iteriert nur über die Länge eines Slice.

** Anhängen mit Slices 

Die Sparche hat eine built-in Funktion namens append um Werte zu einem bestehenden Slice hinzuzufügen.

    var data []string

    for record := 1; record <= 102400; record++ {
        data = append(data, fmt.Sprintf("Rec: %d", record))
    }
Die Funktion "Anhängen" funktioniert mit einem Slice auch dann, wenn das Slice mit dem Wert Null initialisiert ist.
Nullwert-Zustand initialisiert ist. Das API-Design von append ist interessant, weil es die
wertesemantische Mutation verwendet. Append erhält seine eigene Kopie eines Slice-Wertes, verändert seineeigene Kopie und gibt dann eine Kopie an den Aufrufer zurück.

Warum ist die API auf diese Weise konzipiert? Weil es üblich ist, die Wertesemantik zu verwenden
um einen Slice-Wert in einem Programm zu bewegen. Dies muss auch bei einer
Mutationsvorgang eingehalten werden. Außerdem ist die wertesemantische Mutation der sicherste Weg, eine Mutation durchzuführen
da die Mutation an der eigenen, isolierten Kopie der Daten der Funktion durchgeführt wird.

Append behält immer einen zusammenhängenden Speicherblock für das Backing-Array des Slice bei,
auch nach der Vergrösserung. Dies ist wichtig für die Hardware.


.image /tour/eng/static/img/sl2.png

Jedesmal wenn die appen Funktion aufgerufen wird, überprüft die Funktion ob die Grösse und Kapazität des slice 
dieselbe ist. Wenn ja heisst das, es gibt keinen Platz mehr im backing array für den neuen Wert.
In diesem Fall, append kreiert ein neues backing array (verdoppelt oder wächst um 25%) und kopiert dann die Werte des alten Array
in das Neue. Dann kann der neue Wert hinzugefügt werden.

.image /tour/eng/static/img/sl3.png

Wenn nein heisst das, es gibt noch Kapazität für den append. Ein Element wird von der Kapazität weggenommen und
zur Grösse des slice hinzugefügt. Dies macht die append Operation effizient.

Wenn das backing array 1024 Kapazitätselemente oder weniger hat, werden neue backing arrays konstruiert indem die
Grösse des existierenden Arrays verdoppelt wird. Wenn das backing Array grösser als 1024 Elemente anwächst, vergrössert 
sich die Grösse um 25%.

*Beachte:* *Wie* *die* *append* *Funktion* *die* *Kapaziätat* *des backing array anwachsen lässt*
*hat seit* *Go* *1.18. geändert*

- [[https://tip.golang.org/doc/go1.18#runtime][https://tip.golang.org/doc/go1.18#runtime]]

** Slicing Slices

Slices bieten die Möglichkeit, zusätzliche Kopien und Heap-Zuweisungen des Backing-Arrays zu vermeiden
Arrays zu vermeiden, wenn bestimmte Elemente des Backing Arrays für verschiedene
Operationen zu isolieren.

Die Slicing-Syntax entspricht der Listennotation [a:b), was bedeutet, dass die
Elemente von Index a bis b, aber nicht einschließlich b.
    
    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]

Die Variable slice2 ist ein neuer Slice-Wert, der sich nun das gleiche Backing
Array, das slice1 verwendet. Allerdings können Sie mit slice2 nur auf die Elemente
bei den Indizes 2 und 3 (C und D) des Backing-Arrays des ursprünglichen Slice. Die Länge von
slice2 ist 2 und nicht 5 wie in slice1 und die Kapazität ist 3, da es jetzt
3 Elemente ab dieser Zeigerposition gibt.

.image /tour/eng/static/img/sl4.png

Eine bessere Art über slicing nachzudenken ist es sich auf die Grösse wie folgt zu
konzentrieren [a:a+len]. Dies reduziert Fehler beim Berechnen neuer Slices.

Indem man diese inspect Funktion benutzt:

    func inspectSlice(slice []string) {
        fmt.Printf("Length[%d] Capacity[%d]\n", len(slice), cap(slice))
        for i, s := range slice {
            fmt.Printf("[%d] %p %s\n",
                i,
                &slice[i],
                s)
        }
    }

Hier in Aktion:

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]
    inspectSlice(slice1)
    inspectSlice(slice2)

Output:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[2] Capacity[3]
    [0] 0xc00007e020 C     <-- SAME AS INDEX 2 IN SLICE 1
    [1] 0xc00007e030 D     <-- SAME AS INDEX 3 IN SLICE 1


Beachten Sie, dass sich die beiden verschiedenen Slices dasselbe Backing-Array teilen. Sie können
dies durch einen Vergleich der Adressen erkennen.

Das Schöne daran ist, dass es hier keine Zuweisungen gibt. Der Compiler kennt die Größe des
des Backing Array für Slice1 zur Kompilierzeit. Die Übergabe einer Kopie des Slice-Wertes
an die Funktion inspectSlice weitergibt, bleibt alles auf dem Stack.

** Mutationen am Backing Array

Wenn Sie slice2 verwenden, um den Wert der Zeichenkette bei Index 0 zu ändern, wird jeder Slice-Wert
der sich dasselbe Backing-Array teilt (wobei die Adresse für diesen Index Teil
der Länge des Slice ist), wird die Änderung angezeigt.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]
    slice2[0] = "CHANGED"
    inspectSlice(slice1)
    inspectSlice(slice2)

Output:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 CHANGED
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[2] Capacity[3]
    [0] 0xc00007e020 CHANGED
    [1] 0xc00007e030 D

Man muss sich immer bewusst sein, ob der slice an dem man per index einen Wert verändert, das backing Array mit einem anderen Slice teilt.

.image /tour/eng/static/img/sl5.png

Was wenn wir stattdessen eine built-in Funktion anwenden?

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4]
    slice2 = append(slice2, "CHANGED")
    inspectSlice(slice1)
    inspectSlice(slice2)

Output:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 CHANGED
    Length[3] Capacity[3]
    [0] 0xc00007e020 C
    [1] 0xc00007e030 D
    [2] 0xc00007e040 CHANGED

Die Funktion "Anhängen" hat denselben Nebeneffekt, der jedoch nicht sichtbar ist. In diesem Fall,
hat das Einbringen von mehr Länge aus der Kapazität für slice2 dazu geführt, dass der Wert an Adresse
0xc00007e040 geändert wird. Leider hatte Slice1 diese Adresse bereits als
Teil seiner Länge.

.image /tour/eng/static/img/sl6.png

One way to avert the side effect is to use a three index slice when constructing
slice2 so the length and capacity is the same at 2.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice2 := slice1[2:4:4]
    inspectSlice(slice1)
    inspectSlice(slice2)

Output:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[2] Capacity[2]
    [0] 0xc00007e020 C
    [1] 0xc00007e030 D

Die Syntax für ein Slice mit drei Indizes ist [a:b:c], wenn b und c gleich sein sollen
da [a-b] die Länge und [a-c] die Kapazität festlegt. Jetzt sind die Länge und
Kapazität von slice2 identisch.

Nun verwenden Sie wieder die eingebaute Funktion append wie zuvor.

    slice2 := slice1[2:4:4]
    slice2 = append(slice2, "CHANGED")
    inspectSlice(slice1)
    inspectSlice(slice2)

Output:

    Length[5] Capacity[5]
    [0] 0xc00007e000 A
    [1] 0xc00007e010 B
    [2] 0xc00007e020 C
    [3] 0xc00007e030 D
    [4] 0xc00007e040 E
    Length[3] Capacity[4]
    [0] 0xc000016080 C
    [1] 0xc000016090 D
    [2] 0xc0000160a0 CHANGED

Beachten Sie, dass slice2 nach dem Aufruf von append ein neues Backing-Array hat.

.image /tour/eng/static/img/sl7.png

Dies lässt sich durch einen Vergleich der Adressen der einzelnen Slice erkennen. In diesem Fall hat die
Mutation gegen Slice2 keine Nebenwirkung gegen Slice1.

** Slices manuell kopieren

Es gibt eine eingebaute Funktion namens copy, die das flache Kopieren von
von Slices ermöglicht. Da eine Zeichenkette ein Backing-Array von Bytes hat, die unveränderlich sind, kann sie
kann sie als Quelle verwendet werden, aber niemals als Ziel.

    slice1 := []string{"A", "B", "C", "D", "E"}
    slice3 := make([]string, len(slice1))
    copy(slice3, slice1)

    inspectSlice(slice1)
    inspectSlice(slice3)

Output:

    Length[5] Capacity[5]
    [0] 0xc00005c050 A
    [1] 0xc00005c060 B
    [2] 0xc00005c070 C
    [3] 0xc00005c080 D
    [4] 0xc00005c090 E
    Length[5] Capacity[5]
    [0] 0xc00005c0a0 A
    [1] 0xc00005c0b0 B
    [2] 0xc00005c0c0 C
    [3] 0xc00005c0d0 D
    [4] 0xc00005c0e0 E

Solange das Ziel-Slice den richtigen Typ und die richtige Länge hat, kann die eingebaute
Funktion copy eine oberflächliche Kopie durchführen.

** Slices benutzen Pointer Semantic Mutation
Es ist wichtig, sich daran zu erinnern, dass Sie, obwohl Sie die Wertesemantik verwenden, um ein Slice
im Programm bewegen, verwenden Sie beim Lesen und Schreiben eines Slice die Zeigersemantik.
Die gemeinsame Nutzung einzelner Elemente eines Slice in verschiedenen Teilen meines Programms kann
unerwünschte Nebeneffekte verursachen.

    // Construct a slice of 1 user, set a pointer to that user,
    // use the pointer to update likes.

    users := make([]user, 1)
    ptrUsr0 := &users[0]
    ptrUsr0.likes++

    for i := range users {
        fmt.Printf("User: %d Likes: %d\n", i, users[i].likes)
    }

Output:

    User: 0 Likes: 1

A slice is used to maintain a collection of users. Then a pointer is set to the
first user and used to update likes. The output shows that using the pointer is
working.

.image /tour/eng/static/img/sl8.png

Then a new user is appended to the collection and the pointer is used again to
add a like to the first user. 

    // Append a new user to the collection. Use the pointer again
    // to update likes.

    users = append(users, user{})
    ptrUsr0.likes++

    for i := range users {
        fmt.Printf("User: %d Likes: %d\n", i, users[i].likes)
    }

Output:

    User: 0 Likes: 1
    User: 1 Likes: 0

Da jedoch die Append-Funktion das Backing-Array durch ein neues ersetzt hat,
aktualisiert der Zeiger das alte Backing-Array und die entsprechenden Daten gehen verloren. Die Ausgabe
zeigt, dass sich die Likes für den ersten Benutzer nicht erhöht haben.

.image /tour/eng/static/img/sl9.png

Sie müssen darauf achten, dass Sie wissen, ob ein Slice in einer Anfügeoperation
während eines laufenden Programms verwendet wird. Wie Sie das Slice freigeben, muss
berücksichtigen. Die gemeinsame Nutzung einzelner Indizes ist möglicherweise nicht die beste Idee. Das Teilen eines
gesamten Slice-Wertes funktioniert möglicherweise auch nicht, wenn das Anhängen in Betrieb ist. Wahrscheinlich
ist die Verwendung eines Slice als Feld in einer Struktur und die gemeinsame Nutzung des Strukturwertes der bessere
Weg zu gehen.

** Lineare Travessier-Effizienz
Das Schöne an einem Slice ist seine Fähigkeit, lineare Traversals durchzuführen
die mechanisch sympathisch sind, während die gemeinsame Nutzung von Daten mit Hilfe der Wertesemantik zur
Heap-Zuweisungen zu minimieren.

    x := []byte{0x0A, 0x15, 0x0e, 0x28, 0x05, 0x96, 0x0b, 0xd0, 0x0}

    a := x[0]
    b := binary.LittleEndian.Uint16(x[1:3])
    c := binary.LittleEndian.Uint16(x[3:5])
    d := binary.LittleEndian.Uint32(x[5:9])

    println(a, b, c, d)



Der Code führt ein lineares Traversal durch, indem er Slice-Werte erzeugt, die

verschiedene Abschnitte des Byte-Arrays von Anfang bis Ende lesen.
Das Schöne an einem Slice ist seine Fähigkeit, lineare Traversals durchzuführen

.image /tour/eng/static/img/sl10.png

Alle Daten in diesem Code bleiben auf dem Stack. Es werden keine zusätzlichen Kopien der Daten innerhalb
der Byte-Slice werden kopiert.

** Notes
- Slices sind wie dynamische Arrays mit speziellen und eingebauten Funktionen.
- Es gibt einen Unterschied zwischen der Länge und der Kapazität eines Slices, und beide erfüllen einen bestimmten Zweck.
- Slices ermöglichen mehrere "Ansichten" desselben zugrunde liegenden Arrays.
- Slices können durch die Verwendung der eingebauten Funktion append wachsen.

** Extra Reading

- [[https://blog.golang.org/go-slices-usage-and-internals][Go Slices: usage and internals]] - Andrew Gerrand    
- [[https://blog.golang.org/strings][Strings, bytes, runes and characters in Go]] - Rob Pike    
- [[https://blog.golang.org/slices][Arrays, slices (and strings): The mechanics of 'append']] - Rob Pike        
- [[https://www.ardanlabs.com/blog/2013/08/understanding-slices-in-go-programming.html][Understanding Slices in Go Programming]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/08/collections-of-unknown-length-in-go.html][Collections Of Unknown Length in Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/09/iterating-over-slices-in-go.html][Iterating Over Slices In Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/09/slices-of-slices-of-slices-in-go.html][Slices of Slices of Slices in Go]] - William Kennedy    
- [[https://www.ardanlabs.com/blog/2013/12/three-index-slices-in-go-12.html][Three-Index Slices in Go 1.2]] - William Kennedy    
- [[https://github.com/golang/go/wiki/SliceTricks][SliceTricks]]    
- [[https://go-review.googlesource.com/c/go/+/347917][runtime: Make slice growth formula a bit smoother]] - Go Team 
			 
* Exercises
Verwenden Sie die Vorlage als Ausgangspunkt, um die Aufgaben zu lösen. Eine mögliche Lösung ist angegeben.

** Übung 1

*Teil* *A:* Deklarieren Sie eine Nullscheibe von ganzen Zahlen. Erstellen Sie eine Schleife, die 10 Werte
an die Scheibe anhängt. Iterieren Sie über das Slice und zeigen Sie jeden Wert an.

*Teil* *B:* Deklarieren Sie ein Slice mit fünf Strings und initialisieren Sie das Slice mit String
literalen Werten. Zeige alle Elemente an. Nimm ein Slice mit Index eins und zwei und
zeige die Indexposition und den Wert jedes Elements im neuen Slice an.

.play slices/exercise1.go		  
.play slices/answer1.go
